<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>IDA SDK: processor_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="files.html"><span>Header&#160;Files</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="structprocessor__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">processor_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes a processor module (IDP). </p>
<p>An IDP file may have only one such structure called LPH. The kernel will copy it to <a class="el" href="idp_8hpp.html#a1b22cd8cccc4c04160172a9fdc95626b" title="current processor ">ph</a> structure and use <a class="el" href="idp_8hpp.html#a1b22cd8cccc4c04160172a9fdc95626b" title="current processor ">ph</a>. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad15b68b6bdef844bb4481f9535878a2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad15b68b6bdef844bb4481f9535878a2a"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ad15b68b6bdef844bb4481f9535878a2a">version</a></td></tr>
<tr class="memdesc:ad15b68b6bdef844bb4481f9535878a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected kernel version, should be <a class="el" href="idp_8hpp.html#af4b4e4966302754b758c8cc16f964a15" title="The interface version number. ">IDP_INTERFACE_VERSION</a>. <br /></td></tr>
<tr class="separator:ad15b68b6bdef844bb4481f9535878a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6df0facf50afe9dee4716f69739244f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6df0facf50afe9dee4716f69739244f"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ad6df0facf50afe9dee4716f69739244f">id</a></td></tr>
<tr class="memdesc:ad6df0facf50afe9dee4716f69739244f"><td class="mdescLeft">&#160;</td><td class="mdescRight">one of <a class="el" href="group___p_l_f_m__.html">Processor IDs</a> <br /></td></tr>
<tr class="separator:ad6df0facf50afe9dee4716f69739244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6542af67172bea21cda8b81c6671d775"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6542af67172bea21cda8b81c6671d775"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a6542af67172bea21cda8b81c6671d775">flag</a></td></tr>
<tr class="memdesc:a6542af67172bea21cda8b81c6671d775"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html">Processor feature bits</a> <br /></td></tr>
<tr class="separator:a6542af67172bea21cda8b81c6671d775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bbec9142e5695cda6294a9fe85a59c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9bbec9142e5695cda6294a9fe85a59c"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab9bbec9142e5695cda6294a9fe85a59c">flag2</a></td></tr>
<tr class="memdesc:ab9bbec9142e5695cda6294a9fe85a59c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r2__.html">Processor additional feature bits</a> <br /></td></tr>
<tr class="separator:ab9bbec9142e5695cda6294a9fe85a59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86f81b3e716d4bf17f424688cf5aeab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ae86f81b3e716d4bf17f424688cf5aeab">cnbits</a></td></tr>
<tr class="memdesc:ae86f81b3e716d4bf17f424688cf5aeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in a byte for code segments (usually 8).  <a href="#ae86f81b3e716d4bf17f424688cf5aeab">More...</a><br /></td></tr>
<tr class="separator:ae86f81b3e716d4bf17f424688cf5aeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c90b8e3ee733f9f843fc6297bd1977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a94c90b8e3ee733f9f843fc6297bd1977">dnbits</a></td></tr>
<tr class="memdesc:a94c90b8e3ee733f9f843fc6297bd1977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in a byte for non-code segments (usually 8).  <a href="#a94c90b8e3ee733f9f843fc6297bd1977">More...</a><br /></td></tr>
<tr class="separator:a94c90b8e3ee733f9f843fc6297bd1977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13faa23b7174cbdbae5da42c71602d24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structasm__t.html">asm_t</a> *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a13faa23b7174cbdbae5da42c71602d24">assemblers</a></td></tr>
<tr class="memdesc:a13faa23b7174cbdbae5da42c71602d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to array of target assembler definitions.  <a href="#a13faa23b7174cbdbae5da42c71602d24">More...</a><br /></td></tr>
<tr class="separator:a13faa23b7174cbdbae5da42c71602d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61e0933fe94a51df832da1cf0eb25fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af61e0933fe94a51df832da1cf0eb25fd"></a>
<a class="el" href="ida_8hpp.html#acf012fe005690e1af26e799617fc98b7">hook_cb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#af61e0933fe94a51df832da1cf0eb25fd">_notify</a></td></tr>
<tr class="memdesc:af61e0933fe94a51df832da1cf0eb25fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event notification handler. <br /></td></tr>
<tr class="separator:af61e0933fe94a51df832da1cf0eb25fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b75be7e30d134b1b288ab686c312307"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b75be7e30d134b1b288ab686c312307"></a>
const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a0b75be7e30d134b1b288ab686c312307">reg_names</a></td></tr>
<tr class="memdesc:a0b75be7e30d134b1b288ab686c312307"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of register names <br /></td></tr>
<tr class="separator:a0b75be7e30d134b1b288ab686c312307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3a26dcb0ced65a3db134e0b2f90557"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec3a26dcb0ced65a3db134e0b2f90557"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aec3a26dcb0ced65a3db134e0b2f90557">regs_num</a></td></tr>
<tr class="memdesc:aec3a26dcb0ced65a3db134e0b2f90557"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of registers <br /></td></tr>
<tr class="separator:aec3a26dcb0ced65a3db134e0b2f90557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1ea672e493ec9b59b6d3d8e09d69e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a1ea672e493ec9b59b6d3d8e09d69e1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a7a1ea672e493ec9b59b6d3d8e09d69e1">tbyte_size</a></td></tr>
<tr class="memdesc:a7a1ea672e493ec9b59b6d3d8e09d69e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of long double (tbyte) for this processor (meaningful only if <a class="el" href="structasm__t.html#a8bb6b6dcd51fbc50cc03fa5feeff39aa" title="long double; NULL if not allowed ">asm_t::a_tbyte</a> != NULL) <br /></td></tr>
<tr class="separator:a7a1ea672e493ec9b59b6d3d8e09d69e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ed6541f40864dcf175219db42afa90"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab1ed6541f40864dcf175219db42afa90">real_width</a> [4]</td></tr>
<tr class="memdesc:ab1ed6541f40864dcf175219db42afa90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of digits in floating numbers after the decimal point.  <a href="#ab1ed6541f40864dcf175219db42afa90">More...</a><br /></td></tr>
<tr class="separator:ab1ed6541f40864dcf175219db42afa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab497b14d9a38b3b5f04137d554c0e18d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab497b14d9a38b3b5f04137d554c0e18d"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab497b14d9a38b3b5f04137d554c0e18d">icode_return</a></td></tr>
<tr class="memdesc:ab497b14d9a38b3b5f04137d554c0e18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Icode of return instruction. It is ok to give any of possible return instructions. <br /></td></tr>
<tr class="separator:ab497b14d9a38b3b5f04137d554c0e18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62aee2fa2fba2d3a642f730ff0e0c3e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62aee2fa2fba2d3a642f730ff0e0c3e8"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a62aee2fa2fba2d3a642f730ff0e0c3e8">unused_slot</a></td></tr>
<tr class="memdesc:a62aee2fa2fba2d3a642f730ff0e0c3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved, currently equals to NULL. <br /></td></tr>
<tr class="separator:a62aee2fa2fba2d3a642f730ff0e0c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Names</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>IDP module may support several compatible processors.</p>
<p>The following arrays define processor names: </p>
</div></td></tr>
<tr class="memitem:a7f36c9be272d994bc341b3fcb78726f6"><td class="memItemLeft" align="right" valign="top">const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a7f36c9be272d994bc341b3fcb78726f6">psnames</a></td></tr>
<tr class="memdesc:a7f36c9be272d994bc341b3fcb78726f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">short processor names (NULL terminated).  <a href="#a7f36c9be272d994bc341b3fcb78726f6">More...</a><br /></td></tr>
<tr class="separator:a7f36c9be272d994bc341b3fcb78726f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb54cc1d2faab6891ad190e2e5b7bf08"><td class="memItemLeft" align="right" valign="top">const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#adb54cc1d2faab6891ad190e2e5b7bf08">plnames</a></td></tr>
<tr class="memdesc:adb54cc1d2faab6891ad190e2e5b7bf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">long processor names (NULL terminated).  <a href="#adb54cc1d2faab6891ad190e2e5b7bf08">More...</a><br /></td></tr>
<tr class="separator:adb54cc1d2faab6891ad190e2e5b7bf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment registers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Segment register information (use virtual CS and DS registers if your processor doesn't have segment registers): </p>
</div></td></tr>
<tr class="memitem:a4206e35bf99d211c18d53bd1035eb2e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4206e35bf99d211c18d53bd1035eb2e3"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a4206e35bf99d211c18d53bd1035eb2e3">reg_first_sreg</a></td></tr>
<tr class="memdesc:a4206e35bf99d211c18d53bd1035eb2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of first segment register <br /></td></tr>
<tr class="separator:a4206e35bf99d211c18d53bd1035eb2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f70771df2d04aefdfe0d9b7e546d4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2f70771df2d04aefdfe0d9b7e546d4e"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aa2f70771df2d04aefdfe0d9b7e546d4e">reg_last_sreg</a></td></tr>
<tr class="memdesc:aa2f70771df2d04aefdfe0d9b7e546d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of last segment register <br /></td></tr>
<tr class="separator:aa2f70771df2d04aefdfe0d9b7e546d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811665eba68bd3606023c09af8f85705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a811665eba68bd3606023c09af8f85705"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a811665eba68bd3606023c09af8f85705">segreg_size</a></td></tr>
<tr class="memdesc:a811665eba68bd3606023c09af8f85705"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of a segment register in bytes <br /></td></tr>
<tr class="separator:a811665eba68bd3606023c09af8f85705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual segment registers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If your processor doesn't have segment registers, you should define 2 virtual segment registers for CS and DS.</p>
<p>Let's call them rVcs and rVds. </p>
</div></td></tr>
<tr class="memitem:a8c1090cef7d02b379600a8049cd4d25f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c1090cef7d02b379600a8049cd4d25f"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a8c1090cef7d02b379600a8049cd4d25f">reg_code_sreg</a></td></tr>
<tr class="memdesc:a8c1090cef7d02b379600a8049cd4d25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of CS register <br /></td></tr>
<tr class="separator:a8c1090cef7d02b379600a8049cd4d25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bc236f72fe8f6b2b06a8342de8c7ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0bc236f72fe8f6b2b06a8342de8c7ab"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#af0bc236f72fe8f6b2b06a8342de8c7ab">reg_data_sreg</a></td></tr>
<tr class="memdesc:af0bc236f72fe8f6b2b06a8342de8c7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of DS register <br /></td></tr>
<tr class="separator:af0bc236f72fe8f6b2b06a8342de8c7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Empirics</div></td></tr>
<tr class="memitem:a9414a4e585ab47514144871a585cc120"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbytes__t.html">bytes_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a9414a4e585ab47514144871a585cc120">codestart</a></td></tr>
<tr class="memdesc:a9414a4e585ab47514144871a585cc120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of typical code start sequences.  <a href="#a9414a4e585ab47514144871a585cc120">More...</a><br /></td></tr>
<tr class="separator:a9414a4e585ab47514144871a585cc120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3849caf742c36dc743f0aa88267221a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbytes__t.html">bytes_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab3849caf742c36dc743f0aa88267221a">retcodes</a></td></tr>
<tr class="memdesc:ab3849caf742c36dc743f0aa88267221a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of 'return' instruction opcodes.  <a href="#ab3849caf742c36dc743f0aa88267221a">More...</a><br /></td></tr>
<tr class="separator:ab3849caf742c36dc743f0aa88267221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac92d21ee057239e8e72a1773f23d78e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac92d21ee057239e8e72a1773f23d78e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aac92d21ee057239e8e72a1773f23d78e">has_idp_opts</a> (void) const </td></tr>
<tr class="memdesc:aac92d21ee057239e8e72a1773f23d78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">#PR_IDP_OPTS <br /></td></tr>
<tr class="separator:aac92d21ee057239e8e72a1773f23d78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf6dac17a9c16b04fc3d2736d581003"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabf6dac17a9c16b04fc3d2736d581003"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aabf6dac17a9c16b04fc3d2736d581003">has_realcvt</a> (void) const </td></tr>
<tr class="memdesc:aabf6dac17a9c16b04fc3d2736d581003"><td class="mdescLeft">&#160;</td><td class="mdescRight">#PR_REALCVT <br /></td></tr>
<tr class="separator:aabf6dac17a9c16b04fc3d2736d581003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17805487554d99d5854c1cb9f616b34f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17805487554d99d5854c1cb9f616b34f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a17805487554d99d5854c1cb9f616b34f">has_segregs</a> (void) const </td></tr>
<tr class="memdesc:a17805487554d99d5854c1cb9f616b34f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#gaa5d76a1fe1338a80404a0ca7a7ced6d0" title="has segment registers? ">PR_SEGS</a> <br /></td></tr>
<tr class="separator:a17805487554d99d5854c1cb9f616b34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908e565269807e52ddf5d960510f3d29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a908e565269807e52ddf5d960510f3d29"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a908e565269807e52ddf5d960510f3d29">use32</a> (void) const </td></tr>
<tr class="memdesc:a908e565269807e52ddf5d960510f3d29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga4641211435ce736ed30c9ff0a558cf01" title="supports 64-bit addressing? ">PR_USE64</a> or <a class="el" href="group___p_r__.html#gab86fc012cafb2de8b39fefc055941d17" title="supports 32-bit addressing? ">PR_USE32</a> <br /></td></tr>
<tr class="separator:a908e565269807e52ddf5d960510f3d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231aa855508509abc1bb228ad245f5ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a231aa855508509abc1bb228ad245f5ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a231aa855508509abc1bb228ad245f5ce">use64</a> (void) const </td></tr>
<tr class="memdesc:a231aa855508509abc1bb228ad245f5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga4641211435ce736ed30c9ff0a558cf01" title="supports 64-bit addressing? ">PR_USE64</a> <br /></td></tr>
<tr class="separator:a231aa855508509abc1bb228ad245f5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3f1e991fb7ba81b066557108a2436"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecb3f1e991fb7ba81b066557108a2436"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aecb3f1e991fb7ba81b066557108a2436">ti</a> (void) const </td></tr>
<tr class="memdesc:aecb3f1e991fb7ba81b066557108a2436"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga257f9d36eb8bf8c36a28e014f3deedc5" title="the processor module supports type information callbacks ">PR_TYPEINFO</a> <br /></td></tr>
<tr class="separator:aecb3f1e991fb7ba81b066557108a2436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ab83b3afef793c8097a50d498045f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12ab83b3afef793c8097a50d498045f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a12ab83b3afef793c8097a50d498045f4">stkup</a> (void) const </td></tr>
<tr class="memdesc:a12ab83b3afef793c8097a50d498045f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga6bd7458e91aaf2970f7e6e82b87b0c67" title="the stack grows up ">PR_STACK_UP</a> <br /></td></tr>
<tr class="separator:a12ab83b3afef793c8097a50d498045f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24de6bbf100bfb38ed2765066ddd7221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24de6bbf100bfb38ed2765066ddd7221"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a24de6bbf100bfb38ed2765066ddd7221">use_tbyte</a> (void) const </td></tr>
<tr class="memdesc:a24de6bbf100bfb38ed2765066ddd7221"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga196de44585ee70b23e01cb9266aff600" title="BTMT_SPECFLT means _TBYTE type ">PR_USE_TBYTE</a> <br /></td></tr>
<tr class="separator:a24de6bbf100bfb38ed2765066ddd7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93af08fc70f378b9511313cf29932a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af93af08fc70f378b9511313cf29932a6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#af93af08fc70f378b9511313cf29932a6">use_mappings</a> (void) const </td></tr>
<tr class="memdesc:af93af08fc70f378b9511313cf29932a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r2__.html#ga50901ac40fe5f487dcdb5416068d9455" title="the processor module uses memory mapping ">PR2_MAPPINGS</a> <br /></td></tr>
<tr class="separator:af93af08fc70f378b9511313cf29932a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d80ba1324c0aaf9a3adf731d4f468e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23d80ba1324c0aaf9a3adf731d4f468e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a23d80ba1324c0aaf9a3adf731d4f468e">has_thumb</a> (void) const </td></tr>
<tr class="memdesc:a23d80ba1324c0aaf9a3adf731d4f468e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r2__.html#ga74011fc50648b8677793f813c74c023e" title="bit0 of code addresses has special meaning (arm thumb) ">PR2_THUMB_BIT</a> <br /></td></tr>
<tr class="separator:a23d80ba1324c0aaf9a3adf731d4f468e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e0b7613ad405cf7b165b59c9ba02c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ac1e0b7613ad405cf7b165b59c9ba02c0">get_segm_bitness</a> (void) const </td></tr>
<tr class="memdesc:ac1e0b7613ad405cf7b165b59c9ba02c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment bitness.  <a href="#ac1e0b7613ad405cf7b165b59c9ba02c0">More...</a><br /></td></tr>
<tr class="separator:ac1e0b7613ad405cf7b165b59c9ba02c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc5cc7a90ccdd6fc5ef088211bdcf62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bc5cc7a90ccdd6fc5ef088211bdcf62"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notify</b> (<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0">event_t</a> event_code,...)</td></tr>
<tr class="separator:a1bc5cc7a90ccdd6fc5ef088211bdcf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4455b93927159bd4a739b1aceb9983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe4455b93927159bd4a739b1aceb9983"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const char *idp_modname)</td></tr>
<tr class="separator:afe4455b93927159bd4a739b1aceb9983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdb462b00e97eda09f77262c0ee7d05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fdb462b00e97eda09f77262c0ee7d05"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>term</b> ()</td></tr>
<tr class="separator:a6fdb462b00e97eda09f77262c0ee7d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cdb19403d2ec8d52dadcea9bde398c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75cdb19403d2ec8d52dadcea9bde398c"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>newprc</b> (int pnum, bool keep_cfg)</td></tr>
<tr class="separator:a75cdb19403d2ec8d52dadcea9bde398c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3f596cfa224ae0ea00941ce9a88668"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c3f596cfa224ae0ea00941ce9a88668"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>newasm</b> (int asmnum)</td></tr>
<tr class="separator:a3c3f596cfa224ae0ea00941ce9a88668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace44af71e6fd51d053ac4359b24b1e44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace44af71e6fd51d053ac4359b24b1e44"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>newfile</b> (const char *fname)</td></tr>
<tr class="separator:ace44af71e6fd51d053ac4359b24b1e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bc2b0eadec32992263c68130e52a7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69bc2b0eadec32992263c68130e52a7b"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>oldfile</b> (const char *fname)</td></tr>
<tr class="separator:a69bc2b0eadec32992263c68130e52a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f8feec9912fc3e904b2ce0e6b22882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90f8feec9912fc3e904b2ce0e6b22882"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>newbinary</b> (const char *filename, <a class="el" href="pro_8h.html#a42ae75d34f73b9e691bd16aaddb897e5">qoff64_t</a> fileoff, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> basepara, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> binoff, <a class="el" href="pro_8h.html#a2f5563986d7f95e4fad5876c17d9cdda">uint64</a> nbytes)</td></tr>
<tr class="separator:a90f8feec9912fc3e904b2ce0e6b22882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b3ede69991121dde94fc93a3e6310a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73b3ede69991121dde94fc93a3e6310a"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>endbinary</b> (bool ok)</td></tr>
<tr class="separator:a73b3ede69991121dde94fc93a3e6310a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aa024d7c187aa63445d639d9f6ad08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1aa024d7c187aa63445d639d9f6ad08"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>creating_segm</b> (<a class="el" href="classsegment__t.html">segment_t</a> *seg)</td></tr>
<tr class="separator:ac1aa024d7c187aa63445d639d9f6ad08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102ecc9c3a1f4cc4be0b09cdbd00682f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a102ecc9c3a1f4cc4be0b09cdbd00682f"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>assemble</b> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *_bin, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> cs, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ip, bool _use32, const char *line)</td></tr>
<tr class="separator:a102ecc9c3a1f4cc4be0b09cdbd00682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0ed52c3b18846b77d1336e7b800020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e0ed52c3b18846b77d1336e7b800020"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ana_insn</b> (<a class="el" href="classinsn__t.html">insn_t</a> *out)</td></tr>
<tr class="separator:a1e0ed52c3b18846b77d1336e7b800020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a1eac3d08be7b3c6669dbff4ed674c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73a1eac3d08be7b3c6669dbff4ed674c"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>emu_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:a73a1eac3d08be7b3c6669dbff4ed674c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d4ea97428d53055fc0be13063006d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25d4ea97428d53055fc0be13063006d7"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_header</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:a25d4ea97428d53055fc0be13063006d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdf757042f18bee56b4de1537361f92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cdf757042f18bee56b4de1537361f92"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_footer</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:a8cdf757042f18bee56b4de1537361f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd6a4db695b07493493be9bd04b66dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbd6a4db695b07493493be9bd04b66dd"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_segstart</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, <a class="el" href="classsegment__t.html">segment_t</a> *seg)</td></tr>
<tr class="separator:acbd6a4db695b07493493be9bd04b66dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ef517defad729421ace2aaea7e9e3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0ef517defad729421ace2aaea7e9e3d"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_segend</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, <a class="el" href="classsegment__t.html">segment_t</a> *seg)</td></tr>
<tr class="separator:aa0ef517defad729421ace2aaea7e9e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af958c9d126dfa1fe321ed5d4c4e0c2da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af958c9d126dfa1fe321ed5d4c4e0c2da"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_assumes</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:af958c9d126dfa1fe321ed5d4c4e0c2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2456e602cd6efaf827d6435047fe6542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2456e602cd6efaf827d6435047fe6542"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_insn</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:a2456e602cd6efaf827d6435047fe6542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fe55157acf58d4f160e7bf2d67e113"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9fe55157acf58d4f160e7bf2d67e113"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_mnem</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:aa9fe55157acf58d4f160e7bf2d67e113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bb10446bca9768f91a6387ea643f8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28bb10446bca9768f91a6387ea643f8d"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_operand</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, const <a class="el" href="classop__t.html">op_t</a> &amp;op)</td></tr>
<tr class="separator:a28bb10446bca9768f91a6387ea643f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c612748f6fda218e44ea4cb018443c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60c612748f6fda218e44ea4cb018443c"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_data</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, bool analyze_only)</td></tr>
<tr class="separator:a60c612748f6fda218e44ea4cb018443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5d9adb678e9dde281f805a97b5df9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c5d9adb678e9dde281f805a97b5df9c"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_label</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, const char *colored_name)</td></tr>
<tr class="separator:a9c5d9adb678e9dde281f805a97b5df9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee2af27607fc7c121c240ed224bef95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ee2af27607fc7c121c240ed224bef95"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_special_item</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> <a class="el" href="group__seg__type.html#ga67eaaed66c079e1ac389902d19046d20">segtype</a>)</td></tr>
<tr class="separator:a4ee2af27607fc7c121c240ed224bef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab073c3da05fbf7cc4174164d2ce443a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab073c3da05fbf7cc4174164d2ce443a5"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_stkvar_def</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, const class <a class="el" href="classmember__t.html">member_t</a> *mptr, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> v)</td></tr>
<tr class="separator:ab073c3da05fbf7cc4174164d2ce443a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72ad3c218fd059153065a1a75cec325"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af72ad3c218fd059153065a1a75cec325"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_regvar_def</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, <a class="el" href="structregvar__t.html">regvar_t</a> *v)</td></tr>
<tr class="separator:af72ad3c218fd059153065a1a75cec325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbf45e468cd1e7b6a22d7ecacd64421"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabbf45e468cd1e7b6a22d7ecacd64421"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_src_file_lnnum</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, const char *file, size_t lnnum)</td></tr>
<tr class="separator:aabbf45e468cd1e7b6a22d7ecacd64421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e67df5efc18920e0bad7edf1344de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af02e67df5efc18920e0bad7edf1344de"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rename</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, const char *new_name, int flags)</td></tr>
<tr class="separator:af02e67df5efc18920e0bad7edf1344de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5af536c87b32cb6b7bd14fef625388"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba5af536c87b32cb6b7bd14fef625388"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>may_show_sreg</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> current_ea)</td></tr>
<tr class="separator:aba5af536c87b32cb6b7bd14fef625388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b27ed6378b8fd45c704bfb3f5c4c37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9b27ed6378b8fd45c704bfb3f5c4c37"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>coagulate</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> start_ea)</td></tr>
<tr class="separator:af9b27ed6378b8fd45c704bfb3f5c4c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb3616729cfbca0713dd92767a12065"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bb3616729cfbca0713dd92767a12065"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>auto_queue_empty</b> (int type)</td></tr>
<tr class="separator:a9bb3616729cfbca0713dd92767a12065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58099ba9206ccb11760a1985e86f4bd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58099ba9206ccb11760a1985e86f4bd5"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>func_bounds</b> (int *possible_return_code, <a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> max_func_end_ea)</td></tr>
<tr class="separator:a58099ba9206ccb11760a1985e86f4bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af821b38249e800915e8bce8671bd05d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af821b38249e800915e8bce8671bd05d4"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>may_be_func</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int state)</td></tr>
<tr class="separator:af821b38249e800915e8bce8671bd05d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53599f2c48a87e32cd14661aeeb2449"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad53599f2c48a87e32cd14661aeeb2449"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_sane_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int no_crefs)</td></tr>
<tr class="separator:ad53599f2c48a87e32cd14661aeeb2449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794c3d7186affb2d7906a812f7eda6e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a794c3d7186affb2d7906a812f7eda6e8"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_operands</b> (const <a class="el" href="classop__t.html">op_t</a> &amp;op1, const <a class="el" href="classop__t.html">op_t</a> &amp;op2)</td></tr>
<tr class="separator:a794c3d7186affb2d7906a812f7eda6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82efcd2d78094007ba01b896069680d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82efcd2d78094007ba01b896069680d2"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_jump_func</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *jump_target, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *func_pointer)</td></tr>
<tr class="separator:a82efcd2d78094007ba01b896069680d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac200f8e343964827402c5a7ddc97370b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac200f8e343964827402c5a7ddc97370b"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_basic_block_end</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, bool call_insn_stops_block)</td></tr>
<tr class="separator:ac200f8e343964827402c5a7ddc97370b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878d9447be6d7893c68acc8a7d86af2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a878d9447be6d7893c68acc8a7d86af2f"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getreg</b> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *rv, int regnum)</td></tr>
<tr class="separator:a878d9447be6d7893c68acc8a7d86af2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214f82f03f51c39fc7910d3e0f26fc4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a214f82f03f51c39fc7910d3e0f26fc4c"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>undefine</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="separator:a214f82f03f51c39fc7910d3e0f26fc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99650932e10c825fe5f3e099740516a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af99650932e10c825fe5f3e099740516a"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>moving_segm</b> (<a class="el" href="classsegment__t.html">segment_t</a> *seg, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> to, int flags)</td></tr>
<tr class="separator:af99650932e10c825fe5f3e099740516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e543f76da81d49296b4826e0bf69e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a4e543f76da81d49296b4826e0bf69e"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_sp_based</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, const <a class="el" href="classop__t.html">op_t</a> &amp;x)</td></tr>
<tr class="separator:a4a4e543f76da81d49296b4826e0bf69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78e1fca46a156b5c7e5e95e8b8778b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad78e1fca46a156b5c7e5e95e8b8778b3"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_far_jump</b> (int icode)</td></tr>
<tr class="separator:ad78e1fca46a156b5c7e5e95e8b8778b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4560c0ae3df7cd39f133601009b74935"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4560c0ae3df7cd39f133601009b74935"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_call_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:a4560c0ae3df7cd39f133601009b74935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd987acdacd3fe8d6e0146b4117d7af3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd987acdacd3fe8d6e0146b4117d7af3"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_ret_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, bool strict)</td></tr>
<tr class="separator:afd987acdacd3fe8d6e0146b4117d7af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f9f3a712f524e1027345970ec28874"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70f9f3a712f524e1027345970ec28874"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_align_insn</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="separator:a70f9f3a712f524e1027345970ec28874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09baad5c693a6389bdf31131f48aaae2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09baad5c693a6389bdf31131f48aaae2"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>can_have_type</b> (const <a class="el" href="classop__t.html">op_t</a> &amp;op)</td></tr>
<tr class="separator:a09baad5c693a6389bdf31131f48aaae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de0e633060f5493deddd8fc5e1a627d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9de0e633060f5493deddd8fc5e1a627d"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_stkvar_scale_factor</b> ()</td></tr>
<tr class="separator:a9de0e633060f5493deddd8fc5e1a627d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73f75be94e1ca0af932acab98607582"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac73f75be94e1ca0af932acab98607582"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>demangle_name</b> (<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> *res, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, const char *name, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> disable_mask, int demreq)</td></tr>
<tr class="separator:ac73f75be94e1ca0af932acab98607582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631343e64c1c8a430a17475a73a6761d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a631343e64c1c8a430a17475a73a6761d"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_flat_group</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> image_base, int bitness, <a class="el" href="pro_8h.html#a633a07e2920351503da14c0adcd3edfd">sel_t</a> dataseg_sel)</td></tr>
<tr class="separator:a631343e64c1c8a430a17475a73a6761d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cc4334a38a4b7fb2285fe38690a89c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0cc4334a38a4b7fb2285fe38690a89c"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_alloca_probe</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="separator:ae0cc4334a38a4b7fb2285fe38690a89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf89e018a27e8b74dca757320d84c4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaf89e018a27e8b74dca757320d84c4e"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_reg_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, int reg, size_t width, int reghi)</td></tr>
<tr class="separator:afaf89e018a27e8b74dca757320d84c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b5134908d2957919ea3fb71e70a71f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68b5134908d2957919ea3fb71e70a71f"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_asm_or_lst</b> (bool starting, FILE *fp, bool is_asm, int flags, void *outline)</td></tr>
<tr class="separator:a68b5134908d2957919ea3fb71e70a71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d13b140759388e5a7d164a51cb646b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84d13b140759388e5a7d164a51cb646b"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_map_file</b> (int *nlines, FILE *fp)</td></tr>
<tr class="separator:a84d13b140759388e5a7d164a51cb646b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3704c4a670f7f1c88952d841b82077b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3704c4a670f7f1c88952d841b82077b"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_autocmt</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:ad3704c4a670f7f1c88952d841b82077b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275ef4b9e0d43ca32ea9ffb71c2cfea4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a275ef4b9e0d43ca32ea9ffb71c2cfea4"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_insn_table_jump</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:a275ef4b9e0d43ca32ea9ffb71c2cfea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225089e4b8fd141c9fa7a5f17fbeef23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a225089e4b8fd141c9fa7a5f17fbeef23"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>loader_elf_machine</b> (linput_t *li, int machine_type, const char **p_procname, proc_def_t **p_pd)</td></tr>
<tr class="separator:a225089e4b8fd141c9fa7a5f17fbeef23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ab54716e46491bee53031452bb6647"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8ab54716e46491bee53031452bb6647"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_indirect_jump</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:ab8ab54716e46491bee53031452bb6647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcae02a4f27ced49a33d8777cd61383d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcae02a4f27ced49a33d8777cd61383d"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>verify_noreturn</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:afcae02a4f27ced49a33d8777cd61383d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ccf3c1c851aabc99b38e45d8b7c6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67ccf3c1c851aabc99b38e45d8b7c6a"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>verify_sp</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:ae67ccf3c1c851aabc99b38e45d8b7c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94aaeed2010a17765bfbee51a2badff1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94aaeed2010a17765bfbee51a2badff1"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_func_frame</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:a94aaeed2010a17765bfbee51a2badff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5678a9ccb588ae0f1293f272f1baf4ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5678a9ccb588ae0f1293f272f1baf4ca"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_frame_retsize</b> (int *retsize, const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:a5678a9ccb588ae0f1293f272f1baf4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2d29889d63b6339f65850abad123ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f2d29889d63b6339f65850abad123ab"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>analyze_prolog</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> fct_ea)</td></tr>
<tr class="separator:a3f2d29889d63b6339f65850abad123ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff06716780f3c010dcf7cab0510a97c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ff06716780f3c010dcf7cab0510a97c"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_spdelta</b> (<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> *spdelta, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;ins)</td></tr>
<tr class="separator:a0ff06716780f3c010dcf7cab0510a97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a5fe1543fe141cffa37f27d122e00b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90a5fe1543fe141cffa37f27d122e00b"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calcrel</b> (<a class="el" href="classbytevec__t.html">bytevec_t</a> *out, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="separator:a90a5fe1543fe141cffa37f27d122e00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b496cc4ca56c43de481378e3fc51d26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b496cc4ca56c43de481378e3fc51d26"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_reg_value</b> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *out, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int reg)</td></tr>
<tr class="separator:a2b496cc4ca56c43de481378e3fc51d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349c65dc5c4204ed874ec04615542933"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a349c65dc5c4204ed874ec04615542933"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_op_value</b> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *out, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int op)</td></tr>
<tr class="separator:a349c65dc5c4204ed874ec04615542933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdacad16663f79b0957978c94ee62d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcdacad16663f79b0957978c94ee62d3"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>treat_hindering_item</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> hindering_item_ea, <a class="el" href="pro_8h.html#a55dd00e03168fb5180830e87ef0a2c57">flags_t</a> new_item_flags, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> new_item_ea, <a class="el" href="pro_8h.html#adbc570541d9f9a0c4489f9f1fe5f5699">asize_t</a> new_item_length)</td></tr>
<tr class="separator:adcdacad16663f79b0957978c94ee62d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a5009b32f51a909194731b6161eaa5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a5009b32f51a909194731b6161eaa5"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>extract_address</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *out_ea, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> screen_ea, const char *string, size_t x)</td></tr>
<tr class="separator:a77a5009b32f51a909194731b6161eaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf543ba00d87622e9faf2929a0b91ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bf543ba00d87622e9faf2929a0b91ff"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>str2reg</b> (const char *regname)</td></tr>
<tr class="separator:a3bf543ba00d87622e9faf2929a0b91ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cede3a0bb6b279184b88668378a19bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cede3a0bb6b279184b88668378a19bf"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_switch</b> (<a class="el" href="structswitch__info__t.html">switch_info_t</a> *si, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:a5cede3a0bb6b279184b88668378a19bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d641dc226ea211d45d356958b6c62b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d641dc226ea211d45d356958b6c62b6"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_switch_xrefs</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> jumpea, const <a class="el" href="structswitch__info__t.html">switch_info_t</a> &amp;si)</td></tr>
<tr class="separator:a4d641dc226ea211d45d356958b6c62b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00786d3a5112c0c701c0812b70cce7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad00786d3a5112c0c701c0812b70cce7b"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_switch_cases</b> (void *casevec, <a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> *targets, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> insn_ea, const <a class="el" href="structswitch__info__t.html">switch_info_t</a> &amp;si)</td></tr>
<tr class="separator:ad00786d3a5112c0c701c0812b70cce7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b152f1569df75ff8b07475d0d61400"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1b152f1569df75ff8b07475d0d61400"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_bg_color</b> (<a class="el" href="pro_8h.html#a3df5040891132e50157aee66affdf1de">bgcolor_t</a> *color, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="separator:ad1b152f1569df75ff8b07475d0d61400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228b1e8ae1967aeed13c833505960841"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a228b1e8ae1967aeed13c833505960841"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>validate_flirt_func</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> start_ea, const char *funcname)</td></tr>
<tr class="separator:a228b1e8ae1967aeed13c833505960841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe8ce656f1e2b0c182b4cca3fdf4ddb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fe8ce656f1e2b0c182b4cca3fdf4ddb"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_operand_string</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int opnum)</td></tr>
<tr class="separator:a1fe8ce656f1e2b0c182b4cca3fdf4ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23279d562549c187c11e03be7276ede"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab23279d562549c187c11e03be7276ede"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_cref</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> from, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> to, <a class="el" href="group__xref__type.html#ga44e2b79869a9595bbe6265ff2026aa98">cref_t</a> type)</td></tr>
<tr class="separator:ab23279d562549c187c11e03be7276ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53858ff5ffd6177105af3b586a7b9ac2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53858ff5ffd6177105af3b586a7b9ac2"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_dref</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> from, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> to, <a class="el" href="group__xref__type.html#ga78aab6d0d6bd9cb4904bbdbb5ac4fa71">dref_t</a> type)</td></tr>
<tr class="separator:a53858ff5ffd6177105af3b586a7b9ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801ecdbeea89a3837b4f36cbed3e9731"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a801ecdbeea89a3837b4f36cbed3e9731"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>del_cref</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> from, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> to, bool expand)</td></tr>
<tr class="separator:a801ecdbeea89a3837b4f36cbed3e9731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6cac468cc484e58f8b9d3d8ba119c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfd6cac468cc484e58f8b9d3d8ba119c"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>del_dref</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> from, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> to)</td></tr>
<tr class="separator:abfd6cac468cc484e58f8b9d3d8ba119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60ba3abf604d807a566d90eb07f7951"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab60ba3abf604d807a566d90eb07f7951"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>coagulate_dref</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> from, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> to, bool may_define, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *code_ea)</td></tr>
<tr class="separator:ab60ba3abf604d807a566d90eb07f7951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9c046afe0a984c0c05bc330ebd3a53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c9c046afe0a984c0c05bc330ebd3a53"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>set_idp_options</b> (const char *keyword, int vtype, const void *value)</td></tr>
<tr class="separator:a6c9c046afe0a984c0c05bc330ebd3a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d1a97c50ce5628b96cf83ab5e1966e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d1a97c50ce5628b96cf83ab5e1966e"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>set_proc_options</b> (const char *options, int confidence)</td></tr>
<tr class="separator:ab6d1a97c50ce5628b96cf83ab5e1966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e3f0e75719891fd0fc77a04d8f4d1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67e3f0e75719891fd0fc77a04d8f4d1e"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_libfunc_ea</b> (const idasgn_t &amp;sig, const libfunc_t &amp;libfun, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *ea)</td></tr>
<tr class="separator:a67e3f0e75719891fd0fc77a04d8f4d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4371fdb4cf6f689887cfcbd9e18f0c54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4371fdb4cf6f689887cfcbd9e18f0c54"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>realcvt</b> (void *m, unsigned short *e, unsigned short swt)</td></tr>
<tr class="separator:a4371fdb4cf6f689887cfcbd9e18f0c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac766e36c7fcc1e50bd2702a4e5f6eb97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac766e36c7fcc1e50bd2702a4e5f6eb97"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>delay_slot_insn</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *ea, bool *bexec, bool *fexec)</td></tr>
<tr class="separator:ac766e36c7fcc1e50bd2702a4e5f6eb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3813014133afb596fa535507da8b13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf3813014133afb596fa535507da8b13"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_refinfo</b> (<a class="el" href="structrefinfo__t.html">refinfo_t</a> *ri, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, int n, const <a class="el" href="structfixup__data__t.html">fixup_data_t</a> &amp;fd)</td></tr>
<tr class="separator:aaf3813014133afb596fa535507da8b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba085249f03d19e71da9a0c682f745"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53ba085249f03d19e71da9a0c682f745"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_cond_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:a53ba085249f03d19e71da9a0c682f745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dc1c11df02efdbc887058c43e2a7bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5dc1c11df02efdbc887058c43e2a7bd"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>next_exec_insn</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *target, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, int tid, regval_getter_t *_getreg, const <a class="el" href="structregval__t.html">regval_t</a> &amp;regvalues)</td></tr>
<tr class="separator:ae5dc1c11df02efdbc887058c43e2a7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc297252269d28783d8de07a9ae5edb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc297252269d28783d8de07a9ae5edb9"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_step_over</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *target, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ip)</td></tr>
<tr class="separator:abc297252269d28783d8de07a9ae5edb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e1bd1a431a9cdd609c3ae7efc4d4f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5e1bd1a431a9cdd609c3ae7efc4d4f0"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_macro_insn_head</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *head, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ip)</td></tr>
<tr class="separator:ad5e1bd1a431a9cdd609c3ae7efc4d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0511005068143520af107e4b5c3b87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade0511005068143520af107e4b5c3b87"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_dbr_opnum</b> (int *opnum, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:ade0511005068143520af107e4b5c3b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438356b412773f944dad961cbe478972"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a438356b412773f944dad961cbe478972"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insn_reads_tbit</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, regval_getter_t *_getreg, const <a class="el" href="structregval__t.html">regval_t</a> &amp;regvalues)</td></tr>
<tr class="separator:a438356b412773f944dad961cbe478972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0b2efa4b12d83851d0fc8375273ef5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca0b2efa4b12d83851d0fc8375273ef5"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_idd_opinfo</b> (<a class="el" href="structidd__opinfo__t.html">idd_opinfo_t</a> *opinf, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, int n, int thread_id, regval_getter_t *_getreg, const <a class="el" href="structregval__t.html">regval_t</a> &amp;regvalues)</td></tr>
<tr class="separator:aca0b2efa4b12d83851d0fc8375273ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4633e0ee514204edf08003c09cb9f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f4633e0ee514204edf08003c09cb9f4"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_next_eas</b> (<a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> *res, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, bool over)</td></tr>
<tr class="separator:a5f4633e0ee514204edf08003c09cb9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a8c993a7f25cad72a542a2f60a3c44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23a8c993a7f25cad72a542a2f60a3c44"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>clean_tbit</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, regval_getter_t *_getreg, const <a class="el" href="structregval__t.html">regval_t</a> &amp;regvalues)</td></tr>
<tr class="separator:a23a8c993a7f25cad72a542a2f60a3c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435d35e9d9ef5a708c565024ab514feb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a435d35e9d9ef5a708c565024ab514feb"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_reg_info</b> (const char **main_regname, <a class="el" href="classbitrange__t.html">bitrange_t</a> *bitrange, const char *regname)</td></tr>
<tr class="separator:a435d35e9d9ef5a708c565024ab514feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498288d0b0eae31e23cd7a1275e87506"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a498288d0b0eae31e23cd7a1275e87506"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setup_til</b> ()</td></tr>
<tr class="separator:a498288d0b0eae31e23cd7a1275e87506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6339fd474606e98afb912ced953f90ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6339fd474606e98afb912ced953f90ae"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max_ptr_size</b> ()</td></tr>
<tr class="separator:a6339fd474606e98afb912ced953f90ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade850127e6bf2394e070577ddacf0a6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade850127e6bf2394e070577ddacf0a6b"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_default_enum_size</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cm)</td></tr>
<tr class="separator:ade850127e6bf2394e070577ddacf0a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20e7e184653527a2bae6289d617aa59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac20e7e184653527a2bae6289d617aa59"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_cdecl_purged_bytes</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="separator:ac20e7e184653527a2bae6289d617aa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a75bfe85ebc547b7f9b986b62c038e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83a75bfe85ebc547b7f9b986b62c038e"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_stkarg_offset</b> ()</td></tr>
<tr class="separator:a83a75bfe85ebc547b7f9b986b62c038e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54754ec1de88b7a5474a20cad3451d6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54754ec1de88b7a5474a20cad3451d6a"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>equal_reglocs</b> (const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;a1, const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;a2)</td></tr>
<tr class="separator:a54754ec1de88b7a5474a20cad3451d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de2b62b2c8ab178465fcb7a28ba284a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2de2b62b2c8ab178465fcb7a28ba284a"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>decorate_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *outbuf, const char *name, bool mangle, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;type)</td></tr>
<tr class="separator:a2de2b62b2c8ab178465fcb7a28ba284a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d463eb05b2e3a885cbab2aa6cd8bc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2d463eb05b2e3a885cbab2aa6cd8bc3"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_retloc</b> (<a class="el" href="classargloc__t.html">argloc_t</a> *retloc, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;rettype, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="separator:ab2d463eb05b2e3a885cbab2aa6cd8bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320436b85a408a6dcc5dd23d427448a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae320436b85a408a6dcc5dd23d427448a"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_varglocs</b> (<a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *ftd, <a class="el" href="structregobjs__t.html">regobjs_t</a> *regs, <a class="el" href="structrelobj__t.html">relobj_t</a> *stkargs, int nfixed)</td></tr>
<tr class="separator:ae320436b85a408a6dcc5dd23d427448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5182d510ab4bdc120fdf496be32cc258"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5182d510ab4bdc120fdf496be32cc258"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_arglocs</b> (<a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fti)</td></tr>
<tr class="separator:a5182d510ab4bdc120fdf496be32cc258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ffbd809485b6b700094e3cd9b7d36f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09ffbd809485b6b700094e3cd9b7d36f"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>use_stkarg_type</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, const <a class="el" href="structfuncarg__t.html">funcarg_t</a> &amp;arg)</td></tr>
<tr class="separator:a09ffbd809485b6b700094e3cd9b7d36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b7c2da8779fef5d70223cf4b61ed3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19b7c2da8779fef5d70223cf4b61ed3a"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>use_regarg_type</b> (int *idx, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, void *rargs)</td></tr>
<tr class="separator:a19b7c2da8779fef5d70223cf4b61ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7a5f3f545b57cac7544785c23833c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf7a5f3f545b57cac7544785c23833c3"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>use_arg_types</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fti, void *rargs)</td></tr>
<tr class="separator:adf7a5f3f545b57cac7544785c23833c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb438896cb5f4d324a1ad0b85c998aa7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb438896cb5f4d324a1ad0b85c998aa7"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_purged_bytes</b> (int *p_purged_bytes, const <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> &amp;fti)</td></tr>
<tr class="separator:afb438896cb5f4d324a1ad0b85c998aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651aaefc3eebe70057a967c3fad3096f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a651aaefc3eebe70057a967c3fad3096f"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>shadow_args_size</b> (int *shadow_size, <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:a651aaefc3eebe70057a967c3fad3096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351577f6b72869301c5f4615ed25c0b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a351577f6b72869301c5f4615ed25c0b5"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_cc_regs</b> (<a class="el" href="classcallregs__t.html">callregs_t</a> *regs, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="separator:a351577f6b72869301c5f4615ed25c0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1baac2e3217b150f98f2357e981badb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1baac2e3217b150f98f2357e981badb"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_simd_types</b> (void *out, const <a class="el" href="structsimd__info__t.html">simd_info_t</a> *simd_attrs, const <a class="el" href="classargloc__t.html">argloc_t</a> *argloc, bool create_tifs)</td></tr>
<tr class="separator:aa1baac2e3217b150f98f2357e981badb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669da29a2a5a97cc93ea001519ee7c8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a669da29a2a5a97cc93ea001519ee7c8a"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>arg_addrs_ready</b> (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> caller, int n, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *addrs)</td></tr>
<tr class="separator:a669da29a2a5a97cc93ea001519ee7c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbbc88582a2915e87441569264c4208"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bbbc88582a2915e87441569264c4208"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_argloc</b> (<a class="el" href="classargloc__t.html">argloc_t</a> *argloc, const <a class="el" href="classtinfo__t.html">tinfo_t</a> *type, int size)</td></tr>
<tr class="separator:a5bbbc88582a2915e87441569264c4208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbdfae149a1fd6417fdce6b90494461"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dbdfae149a1fd6417fdce6b90494461"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lower_func_type</b> (<a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *argnums, <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fti)</td></tr>
<tr class="separator:a6dbdfae149a1fd6417fdce6b90494461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8043e53c1cfe729c6039e494098643"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc8043e53c1cfe729c6039e494098643"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_abi_info</b> (<a class="el" href="pro_8h.html#a823b67c620f6cdca97e1d969ea4a9b02">qstrvec_t</a> *abi_names, <a class="el" href="pro_8h.html#a823b67c620f6cdca97e1d969ea4a9b02">qstrvec_t</a> *abi_opts, <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a> comp)</td></tr>
<tr class="separator:adc8043e53c1cfe729c6039e494098643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe691f9f3c80817bd9d1e19e8ee5f926"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#abe691f9f3c80817bd9d1e19e8ee5f926">get_stkvar_scale</a> (void)</td></tr>
<tr class="memdesc:abe691f9f3c80817bd9d1e19e8ee5f926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stack variable scaling factor.  <a href="#abe691f9f3c80817bd9d1e19e8ee5f926">More...</a><br /></td></tr>
<tr class="separator:abe691f9f3c80817bd9d1e19e8ee5f926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Byte size</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Number of 8bit bytes required to hold one byte of the target processor.</p>
</div></td></tr>
<tr class="memitem:a33f991813d3e0cc28375d5330dd246f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33f991813d3e0cc28375d5330dd246f3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a33f991813d3e0cc28375d5330dd246f3">cbsize</a> (void)</td></tr>
<tr class="memdesc:a33f991813d3e0cc28375d5330dd246f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">for code segments <br /></td></tr>
<tr class="separator:a33f991813d3e0cc28375d5330dd246f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d79d528bb32036ab8d76d102ee0037f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d79d528bb32036ab8d76d102ee0037f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a3d79d528bb32036ab8d76d102ee0037f">dbsize</a> (void)</td></tr>
<tr class="memdesc:a3d79d528bb32036ab8d76d102ee0037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">for non-code segments <br /></td></tr>
<tr class="separator:a3d79d528bb32036ab8d76d102ee0037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2d184a313fab28b517e82c1717d562a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0">event_t</a> { <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8902d365f396d75e96a81c73b02ca13c">ev_init</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a93a414d2d7ac3eeee04c19853b53bd27">ev_term</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a190f0300a7e6ad8e090389f7b986e9f8">ev_newprc</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0af0b69a407fcdc6e5627901c6b3e5f4a6">ev_newasm</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0af544684794ac0f908ba551b0085482a9">ev_newfile</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae9430716ca6d6e53548863cce8fd839f">ev_oldfile</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a20b00ee7b8f4f3ce47579430ce3fa1c0">ev_newbinary</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0886df8414100bfdcaacf87a8ae165e7">ev_endbinary</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a77fb9c9858c9519da17acd2a2bc60391">ev_set_idp_options</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a47bcbd0313ef457a9ff2b6330ab80af3">ev_set_proc_options</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a108d52b9133787bd01c5ca8a7550f2e9">ev_ana_insn</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a82b81ce84c2257cb5a9176648e2fd6fc">ev_emu_insn</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ac286cd442f5f923d434a9a420d2639e8">ev_out_header</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae78a32919dde7288ed2e816658081c2a">ev_out_footer</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae9a7ac704447bbbd50dface52b617807">ev_out_segstart</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a9153e7bd063780720b8761a8e7371a25">ev_out_segend</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0abf9364c0e642488fac29f61f2b6d0e00">ev_out_assumes</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8edf4ec2bd23d42d3db641761b3156de">ev_out_insn</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a25783c63147edce4591595cba57d1fb3">ev_out_mnem</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8312057bdefad72948a26885372af286">ev_out_operand</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a960b08cf65ab07718b9c1eeab0f3288b">ev_out_data</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4fc4ad04d596de2dbea5694286bd461e">ev_out_label</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a15733589357bcc46d558536220edcb81">ev_out_special_item</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1790c885236860f938b0c7e983fac38f">ev_gen_stkvar_def</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a44268c939ffcc2e8c4c54a1c75796bc0">ev_gen_regvar_def</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0b636852302fb6ded9309c69cb984f75">ev_gen_src_file_lnnum</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a50e477c14c432b24b7415aa3d96f4a9d">ev_creating_segm</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa3c9018493b02e6d0e2b5a4ac7b7549b">ev_moving_segm</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a08fe9e01fa7424bd80e734a963c1b16a">ev_coagulate</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a326c50bb55c58af34774e6fbab74214c">ev_undefine</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae96a0913cd051a9a7861ff2d3514a370">ev_treat_hindering_item</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a2a2bb0b58f0b5ab62748063b0e601a0e">ev_rename</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa0a7a527f9e9cba6c406358fad2d4ab1">ev_is_far_jump</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aca1ba6609e0e3814c499511d513eb099">ev_is_sane_insn</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0addaf1f6a31bbefb8033c27edc0950cb8">ev_is_cond_insn</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa62d5d4207c7aee3967ab8abddb8c3c1">ev_is_call_insn</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0abec6210c7336a864b70a7e5e94a9ac9d">ev_is_ret_insn</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a2e378dfbfccdef3feaa2da1bab69326e">ev_may_be_func</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a978a9e36b842dfe0e7380c3521fa2e1d">ev_is_basic_block_end</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a11d97a517b214dfde194a1de69e5e5ab">ev_is_indirect_jump</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0adeb44139bfc91c40cb8e3bd93659ca8e">ev_is_insn_table_jump</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a9d42d8c2836dceec7666e4b8eb6f71a1">ev_is_switch</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a98ff2357b62ae2783e781073a9549578">ev_calc_switch_cases</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ab1fe188a32b7e4eeedbbbcbe5066af56">ev_create_switch_xrefs</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4d200c0f82f9d32c4bda426aadc3e9dc">ev_is_align_insn</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ad25720c4c15166242743be03127e0a84">ev_is_alloca_probe</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0af754550ff044ee8ba2bf4b90037eb4b1">ev_delay_slot_insn</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aef2ae5d93a83201e69e626f1308ca21f">ev_is_sp_based</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a9b1b28b1c71c8d77861f528c78eade90">ev_can_have_type</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a2996b08408addef7f16b01180e2efdc3">ev_cmp_operands</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0abf55189dd21fab945f35eab8fa9088cf">ev_adjust_refinfo</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae7391e79329dedc4bd100a629e61f569">ev_get_operand_string</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8dcc2b7307fb19045e6acf6d6016d89d">ev_get_reg_name</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aaddd272c33f61d746f850746a5451a9f">ev_str2reg</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0fa6560db645bbc4751b5cee7760cf30">ev_get_autocmt</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0de30b0749ce3401ec930a1904bcb274">ev_get_bg_color</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1f6f7128d8213f4433c5c94e16635aa7">ev_is_jump_func</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a54a6dfcb795c6d8167ebdb5116bcf579">ev_func_bounds</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a726a4a238e3c41a53777e5e04b911029">ev_verify_sp</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae161c5b9fbb789a4ed5a9e88539802f7">ev_verify_noreturn</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4e97147365c7e9487f57ffc2bd82894a">ev_create_func_frame</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a73d90e8e78294379f7efdb58e0fa4ca9">ev_get_frame_retsize</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae3c289592a68b9362e83fab157097cbf">ev_get_stkvar_scale_factor</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ad1283662b4901e2ea7d85af70bc7f817">ev_demangle_name</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a6362bc58103da0a115d1c15c3ce41fe1">ev_add_cref</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a64a7c332726e8a44498b879162e4d24f">ev_add_dref</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a58ace401d909f95b24a1e8fcae9810d4">ev_del_cref</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0affd5e295fef35e6175c3db5150ca5396">ev_del_dref</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a00c056a442c9524d2c7f7e90669c8275">ev_coagulate_dref</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1edb3d05f21feee48cf7d271032dcbc2">ev_may_show_sreg</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a268f12ba7873a0778460826a59e268aa">ev_loader_elf_machine</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0ca73f0b4d8eb1c319f668cb8c520b86">ev_auto_queue_empty</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aac26bb0ae2ef530084cbeb8c3078bd43">ev_validate_flirt_func</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1cf0dcb7a9e11a5220863ddb8722bd09">ev_adjust_libfunc_ea</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5f2ba1e8f4586958cc9cef0f514667e2">ev_assemble</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0abe5d814d671bf8564be4212cefb61238">ev_extract_address</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5cccab69e499642d3873649769de31cf">ev_realcvt</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a87a749b6180d2fc6c4b4436df4eddc2f">ev_gen_asm_or_lst</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ac4729fbc053f45a29a9370369eda3c21">ev_gen_map_file</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5fa3981e47a82bf57567c9e17fc69344">ev_create_flat_group</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5b7199e3af11fa25303602ba6093f307">ev_getreg</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ada84ccdbecd828227cf5891289d4a442">ev_analyze_prolog</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ad634ef51985fc184b924840188825199">ev_calc_spdelta</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a44113b21d13cb880233a52c38a84bea9">ev_calcrel</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a05a8170fb8a243187c118dbcaa1fd954">ev_find_reg_value</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ac0cdca25f97d06dfa6630abfd371cfea">ev_find_op_value</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5776ce7324886d47497e6b55fa985c2f">ev_last_cb_before_debugger</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a035854be86d6e113db368eba96ec6a44">ev_next_exec_insn</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa552c713d33cbf8b7088aa1279316279">ev_calc_step_over</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a15f393eb309882f724a87ba8680ed8b2">ev_calc_next_eas</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a2f4da6daaf29d96db466f024a41b6cd6">ev_get_macro_insn_head</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae19b6e2ec1f0f8dff6822e23d26ecf6f">ev_get_dbr_opnum</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a744ce375c380a22ef248cb5c8b2fe91e">ev_insn_reads_tbit</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a731a21b42e23b3a93212acc929590a44">ev_clean_tbit</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4c99f3d0cae242c834db12429824c412">ev_get_idd_opinfo</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ac3cc0f61a972f10943ffcb9b512bbfcd">ev_get_reg_info</a>, 
<br />
&#160;&#160;<b>ev_last_cb_before_type_callbacks</b>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ab943223f3ca8d738c6a33aa2d1d5d5b2">ev_setup_til</a> = 2000, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa97519e3d4a7c838b5bea894471d1605">ev_get_abi_info</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa72e8b0fefe1ccb4f97c3ab7d963403e">ev_max_ptr_size</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a445f041d8992406148c70d2265aeeaeb">ev_get_default_enum_size</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4d4579748c4e9235161552951f41243e">ev_get_cc_regs</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a47951bf3b092b3fbc1750c48988a00a0">ev_get_stkarg_offset</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a81a915a392ccbe061321cf7fd8bb3091">ev_shadow_args_size</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0afa23f72943023fbb22dbc682beca757c">ev_get_simd_types</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae4a7bab1ce8d51fef3323630c8ab5986">ev_calc_cdecl_purged_bytes</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a04dc0f7ffee5e8ce6d9bd2659f5fb48d">ev_calc_purged_bytes</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0d69f230a16256b7c97ec87e16a6f814">ev_calc_retloc</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8db94c9ea9bd7e6039821e897b952f82">ev_calc_arglocs</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4537faf41cc6bd81946ec4cfd4b2db5a">ev_calc_varglocs</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae6d879a79e41acf6c15241f8a8616413">ev_adjust_argloc</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0af54f85e43c332ae869c5e9015e1f3203">ev_lower_func_type</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aacf3158cd80a47e0f87786c60f6f1b6a">ev_equal_reglocs</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5551d04ee2e1a9f77a06ea2da02e5ffc">ev_use_stkarg_type</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a239afca977e96df72bf4680c8843662a">ev_use_regarg_type</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a97d8ef8f70c0d9e0e53726ab6cea7671">ev_use_arg_types</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a63c06a7cbeccfbc66ba9981ccde80e77">ev_arg_addrs_ready</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8341bbf9f53b19f61d4d7adcdc51783b">ev_decorate_name</a>, 
<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a562fb16cff7e5e0c0f5750788c24d99c">ev_loader</a> =3000
<br />
 }</td></tr>
<tr class="memdesc:a2d184a313fab28b517e82c1717d562a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback notification codes.  <a href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0">More...</a><br /></td></tr>
<tr class="separator:a2d184a313fab28b517e82c1717d562a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4346317d32879e39e894f3d9d616b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d4346317d32879e39e894f3d9d616b2"></a>
typedef const <a class="el" href="structregval__t.html">regval_t</a> &amp;<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a>&#160;</td><td class="memItemRight" valign="bottom"><b>regval_getter_t</b>(const char *name, const <a class="el" href="structregval__t.html">regval_t</a> *regvalues)</td></tr>
<tr class="separator:a6d4346317d32879e39e894f3d9d616b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Instruction set</h2></td></tr>
<tr class="memitem:a35f080945b61116baab1bfc67f195f62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35f080945b61116baab1bfc67f195f62"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a35f080945b61116baab1bfc67f195f62">instruc_start</a></td></tr>
<tr class="memdesc:a35f080945b61116baab1bfc67f195f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">icode of the first instruction <br /></td></tr>
<tr class="separator:a35f080945b61116baab1bfc67f195f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc594ff4b32014972b205b5c9b07deb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc594ff4b32014972b205b5c9b07deb"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a5bc594ff4b32014972b205b5c9b07deb">instruc_end</a></td></tr>
<tr class="memdesc:a5bc594ff4b32014972b205b5c9b07deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">icode of the last instruction + 1 <br /></td></tr>
<tr class="separator:a5bc594ff4b32014972b205b5c9b07deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb7cfbf39771b646cfc5e5d43259175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fb7cfbf39771b646cfc5e5d43259175"></a>
const <a class="el" href="structinstruc__t.html">instruc_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a6fb7cfbf39771b646cfc5e5d43259175">instruc</a></td></tr>
<tr class="memdesc:a6fb7cfbf39771b646cfc5e5d43259175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of instructions. <br /></td></tr>
<tr class="separator:a6fb7cfbf39771b646cfc5e5d43259175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58c2a400e68a56e9299338aab2b2029"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ad58c2a400e68a56e9299338aab2b2029">is_canon_insn</a> (<a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> itype) const </td></tr>
<tr class="memdesc:ad58c2a400e68a56e9299338aab2b2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given value specify a valid instruction for this instruction set?.  <a href="#ad58c2a400e68a56e9299338aab2b2029">More...</a><br /></td></tr>
<tr class="separator:ad58c2a400e68a56e9299338aab2b2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a2d184a313fab28b517e82c1717d562a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0">processor_t::event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback notification codes. </p>
<p>These are passed to notify() when certain events occur in the kernel, allowing the processor module to take appropriate action.</p>
<p>If you are not developing a processor module, many of these codes already have a corresponding function to use instead ( <a class="el" href="">is_call_insn</a> vs is_call_insn(ea_t), for example).</p>
<p>If you are developing a processor module, your notify() function must implement the desired behavior when called with a given code. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a8902d365f396d75e96a81c73b02ca13c"></a>ev_init&#160;</td><td class="fielddoc">
<p>The IDP module is just loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idp_modname</td><td>(const char *) processor module name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 on failure </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a93a414d2d7ac3eeee04c19853b53bd27"></a>ev_term&#160;</td><td class="fielddoc">
<p>The IDP module is being unloaded. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a190f0300a7e6ad8e090389f7b986e9f8"></a>ev_newprc&#160;</td><td class="fielddoc">
<p>Before changing processor type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnum</td><td>(int) processor number in the array of processor names </td></tr>
    <tr><td class="paramname">keep_cfg</td><td>(bool) true: do not modify kernel configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;0</td><td>prohibit </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0af0b69a407fcdc6e5627901c6b3e5f4a6"></a>ev_newasm&#160;</td><td class="fielddoc">
<p>Before setting a new assembler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asmnum</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0af544684794ac0f908ba551b0085482a9"></a>ev_newfile&#160;</td><td class="fielddoc">
<p>A new file has been loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>(char *) input file name </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae9430716ca6d6e53548863cce8fd839f"></a>ev_oldfile&#160;</td><td class="fielddoc">
<p>An old file has been loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>(char *) input file name </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a20b00ee7b8f4f3ce47579430ce3fa1c0"></a>ev_newbinary&#160;</td><td class="fielddoc">
<p>IDA is about to load a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>(char *) binary file name </td></tr>
    <tr><td class="paramname">fileoff</td><td>(<a class="el" href="pro_8h.html#a42ae75d34f73b9e691bd16aaddb897e5" title="file offset ">qoff64_t</a>) offset in the file </td></tr>
    <tr><td class="paramname">basepara</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) base loading paragraph </td></tr>
    <tr><td class="paramname">binoff</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) loader offset </td></tr>
    <tr><td class="paramname">nbytes</td><td>(<a class="el" href="pro_8h.html#a2f5563986d7f95e4fad5876c17d9cdda" title="unsigned 64 bit value ">uint64</a>) number of bytes to load </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a0886df8414100bfdcaacf87a8ae165e7"></a>ev_endbinary&#160;</td><td class="fielddoc">
<p>IDA has loaded a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ok</td><td>(bool) file loaded successfully? </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a77fb9c9858c9519da17acd2a2bc60391"></a>ev_set_idp_options&#160;</td><td class="fielddoc">
<p>Set IDP-specific configuration option Also see set_options_t above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>(const char *) </td></tr>
    <tr><td class="paramname">value_type</td><td>(int) </td></tr>
    <tr><td class="paramname">value</td><td>(const void *) </td></tr>
    <tr><td class="paramname">errbuf</td><td>(const char **) - a error message will be returned here (can be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd>
<dd>
-1 error (and message in errbuf) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a47bcbd0313ef457a9ff2b6330ab80af3"></a>ev_set_proc_options&#160;</td><td class="fielddoc">
<p>Called if the user specified an option string in the command line: -p&lt;processor name&gt;=""&gt;:&lt;options&gt;. </p>
<p>Can be used for setting a processor subtype. Also called if option string is passed to <a class="el" href="idp_8hpp.html#a2e01ca60cc6559ab1dbbfbb9562d6870" title="Set target processor type. ">set_processor_type()</a> and IDC's SetProcessorType(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>(const char *) </td></tr>
    <tr><td class="paramname">confidence</td><td>(int) 0: loader's suggestion 1: user's decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if bad option string </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a108d52b9133787bd01c5ca8a7550f2e9"></a>ev_ana_insn&#160;</td><td class="fielddoc">
<p>Analyze one instruction and fill 'out' structure. </p>
<p>This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. {ea} contains address of instruction to analyze. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(<a class="el" href="classinsn__t.html">insn_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the instruction in bytes, 0 if instruction can't be decoded. </dd>
<dd>
0 if instruction can't be decoded. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a82b81ce84c2257cb5a9176648e2fd6fc"></a>ev_emu_insn&#160;</td><td class="fielddoc">
<p>Emulate instruction, create cross-references, plan to analyze subsequent instructions, modify flags etc. </p>
<p>Upon entrance to this function, all information about the instruction is in 'insn' structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
-1 the kernel will delete the instruction </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ac286cd442f5f923d434a9a420d2639e8"></a>ev_out_header&#160;</td><td class="fielddoc">
<p>Function to produce start of disassembled text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae78a32919dde7288ed2e816658081c2a"></a>ev_out_footer&#160;</td><td class="fielddoc">
<p>Function to produce end of disassembled text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae9a7ac704447bbbd50dface52b617807"></a>ev_out_segstart&#160;</td><td class="fielddoc">
<p>Function to produce start of segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment. ">segment_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a9153e7bd063780720b8761a8e7371a25"></a>ev_out_segend&#160;</td><td class="fielddoc">
<p>Function to produce end of segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment. ">segment_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0abf9364c0e642488fac29f61f2b6d0e00"></a>ev_out_assumes&#160;</td><td class="fielddoc">
<p>Function to produce assume directives when segment register value changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a8edf4ec2bd23d42d3db641761b3156de"></a>ev_out_insn&#160;</td><td class="fielddoc">
<p>Generate text representation of an instruction in 'ctx.insn' <a class="el" href="structoutctx__t.html">outctx_t</a> provides functions to output the generated text. </p>
<p>This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a25783c63147edce4591595cba57d1fb3"></a>ev_out_mnem&#160;</td><td class="fielddoc">
<p>Generate instruction mnemonics. </p>
<p>This callback should append the colored mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if appended the mnemonics </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a8312057bdefad72948a26885372af286"></a>ev_out_operand&#160;</td><td class="fielddoc">
<p>Generate text representation of an instruction operand <a class="el" href="structoutctx__t.html">outctx_t</a> provides functions to output the generated text. </p>
<p>All these actions should be performed only by emu_insn() function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">op</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction. ">op_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
-1 operand is hidden </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a960b08cf65ab07718b9c1eeab0f3288b"></a>ev_out_data&#160;</td><td class="fielddoc">
<p>Generate text representation of data items This function may change the database and create cross-references if analyze_only is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">analyze_only</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a4fc4ad04d596de2dbea5694286bd461e"></a>ev_out_label&#160;</td><td class="fielddoc">
<p>The kernel is going to generate an instruction label line or a function header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">colored_name</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if the kernel should not generate the label </dd>
<dd>
0 not implemented or continue </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a15733589357bcc46d558536220edcb81"></a>ev_out_special_item&#160;</td><td class="fielddoc">
<p>Generate text representation of an item in a special segment i.e. </p>
<p>absolute symbols, externs, communal definitions etc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">segtype</td><td>(uchar) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd>
<dd>
-1 overflow </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a1790c885236860f938b0c7e983fac38f"></a>ev_gen_stkvar_def&#160;</td><td class="fielddoc">
<p>Generate stack variable definition line Default line is varname = type ptr value, where 'type' is one of byte,word,dword,qword,tbyte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">mptr</td><td>(const <a class="el" href="classmember__t.html" title="Describes a member of an assembly level structure. ">member_t</a> *) </td></tr>
    <tr><td class="paramname">v</td><td>(sval_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 - ok </dd>
<dd>
0 - not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a44268c939ffcc2e8c4c54a1c75796bc0"></a>ev_gen_regvar_def&#160;</td><td class="fielddoc">
<p>Generate register variable definition line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">v</td><td>(<a class="el" href="structregvar__t.html" title="A register variable allows the user to rename a general processor register to a meaningful name...">regvar_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>ok, generated the definition text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a0b636852302fb6ded9309c69cb984f75"></a>ev_gen_src_file_lnnum&#160;</td><td class="fielddoc">
<p>Callback: generate analog of: </p>
<p>#line "file.c" 123</p>
<p>directive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) output context </td></tr>
    <tr><td class="paramname">file</td><td>(const char *) source file (may be NULL) </td></tr>
    <tr><td class="paramname">lnnum</td><td>(size_t) line number </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>directive has been generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a50e477c14c432b24b7415aa3d96f4a9d"></a>ev_creating_segm&#160;</td><td class="fielddoc">
<p>A new segment is about to be created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment. ">segment_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;0</td><td>segment should not be created </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aa3c9018493b02e6d0e2b5a4ac7b7549b"></a>ev_moving_segm&#160;</td><td class="fielddoc">
<p>May the kernel move the segment? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment. ">segment_t</a> *) segment to move </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) new segment start address </td></tr>
    <tr><td class="paramname">flags</td><td>(int) combination of <a class="el" href="group___m_s_f__.html">Move segment flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>yes </td></tr>
    <tr><td class="paramname">&lt;0</td><td>the kernel should stop </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a08fe9e01fa7424bd80e734a963c1b16a"></a>ev_coagulate&#160;</td><td class="fielddoc">
<p>Try to define some unexplored bytes. </p>
<p>This notification will be called if the kernel tried all possibilities and could not find anything more useful than to convert to array of bytes. The module can help the kernel and convert the bytes into something more useful. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of converted bytes </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a326c50bb55c58af34774e6fbab74214c"></a>ev_undefine&#160;</td><td class="fielddoc">
<p>An item in the database (insn or data) is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(ea_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 do not delete srranges at the item end </dd>
<dd>
0 srranges can be deleted </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae96a0913cd051a9a7861ff2d3514a370"></a>ev_treat_hindering_item&#160;</td><td class="fielddoc">
<p>An item hinders creation of another item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hindering_item_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">new_item_flags</td><td>(<a class="el" href="pro_8h.html#a55dd00e03168fb5180830e87ef0a2c57" title="32-bit flags for each address ">flags_t</a>) (0 for code) </td></tr>
    <tr><td class="paramname">new_item_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">new_item_length</td><td>(<a class="el" href="pro_8h.html#adbc570541d9f9a0c4489f9f1fe5f5699" title="memory chunk size ">asize_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>no reaction </td></tr>
    <tr><td class="paramname">!=0</td><td>the kernel may delete the hindering item </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a2a2bb0b58f0b5ab62748063b0e601a0e"></a>ev_rename&#160;</td><td class="fielddoc">
<p>The kernel is going to rename a byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">new_name</td><td>(const char *) </td></tr>
    <tr><td class="paramname">flags</td><td>(int) <a class="el" href="group___s_n__.html">Set name flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if the kernel should not rename it. </dd>
<dd>
2 to inhibit the notification. I.e., the kernel should not rename, but '<a class="el" href="name_8hpp.html#aa75fb1ba89bb22f323472e329eb4a486" title="Set or delete name of an item at the specified address. ">set_name()</a>' should return 'true'. also see <a class="el" href="">renamed</a> the return value is ignored when kernel is going to delete name </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aa0a7a527f9e9cba6c406358fad2d4ab1"></a>ev_is_far_jump&#160;</td><td class="fielddoc">
<p>is indirect far jump or call instruction? meaningful only if the processor has 'near' and 'far' reference types </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">icode</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 not implemented </dd>
<dd>
1 yes </dd>
<dd>
-1 no </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aca1ba6609e0e3814c499511d513eb099"></a>ev_is_sane_insn&#160;</td><td class="fielddoc">
<p>Is the instruction sane for the current file type?. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">no_crefs</td><td>(int) 1: the instruction has no code refs to it. ida just tries to convert unexplored bytes to an instruction (but there is no other reason to convert them into an instruction) 0: the instruction is created because of some coderef, user request or another weighty reason. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;=0</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no, the instruction isn't likely to appear in the program </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0addaf1f6a31bbefb8033c27edc0950cb8"></a>ev_is_cond_insn&#160;</td><td class="fielddoc">
<p>Is conditional instruction? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">-1</td><td>no </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or not instruction </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aa62d5d4207c7aee3967ab8abddb8c3c1"></a>ev_is_call_insn&#160;</td><td class="fielddoc">
<p>Is the instruction a "call"? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">1</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0abec6210c7336a864b70a7e5e94a9ac9d"></a>ev_is_ret_insn&#160;</td><td class="fielddoc">
<p>Is the instruction a "return"? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction </td></tr>
    <tr><td class="paramname">strict</td><td>(bool) 1: report only ret instructions 0: include instructions like "leave" which begins the function epilog </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">1</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a2e378dfbfccdef3feaa2da1bab69326e"></a>ev_may_be_func&#160;</td><td class="fielddoc">
<p>Can a function start here? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">state</td><td>(int) autoanalysis phase 0: creating functions 1: creating chunks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>probability 0..100 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a978a9e36b842dfe0e7380c3521fa2e1d"></a>ev_is_basic_block_end&#160;</td><td class="fielddoc">
<p>Is the current instruction end of a basic block?. </p>
<p>This function should be defined for processors with delayed jump slots. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">call_insn_stops_block</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">1</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a11d97a517b214dfde194a1de69e5e5ab"></a>ev_is_indirect_jump&#160;</td><td class="fielddoc">
<p>Determine if instruction is an indirect jump. </p>
<p>If <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a> bit can not describe all jump types jumps, please define this callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>use <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a> </td></tr>
    <tr><td class="paramname">1</td><td>no </td></tr>
    <tr><td class="paramname">2</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0adeb44139bfc91c40cb8e3bd93659ca8e"></a>ev_is_insn_table_jump&#160;</td><td class="fielddoc">
<p>Determine if instruction is a table jump or call. </p>
<p>If <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a> bit can not describe all kinds of table jumps, please define this callback. It will be called for insns with <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a> bit set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>yes </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a9d42d8c2836dceec7666e4b8eb6f71a1"></a>ev_is_switch&#160;</td><td class="fielddoc">
<p>Find 'switch' idiom. </p>
<p>It will be called for instructions marked with <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">si</td><td>(<a class="el" href="structswitch__info__t.html" title="Information about a switch statement. ">switch_info_t</a> *), out </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction possibly belonging to a switch </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>switch is found, 'si' is filled </td></tr>
    <tr><td class="paramname">0</td><td>no switch found or not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a98ff2357b62ae2783e781073a9549578"></a>ev_calc_switch_cases&#160;</td><td class="fielddoc">
<p>Calculate case values and targets for a custom jump table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">casevec</td><td>(::casevec_t *) vector of case values (may be NULL) </td></tr>
    <tr><td class="paramname">targets</td><td>(<a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4" title="vector of addresses ">eavec_t</a> *) corresponding target addresses (my be NULL) </td></tr>
    <tr><td class="paramname">insn_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the 'indirect jump' instruction </td></tr>
    <tr><td class="paramname">si</td><td>(<a class="el" href="structswitch__info__t.html" title="Information about a switch statement. ">switch_info_t</a> *) switch information </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ab1fe188a32b7e4eeedbbbcbe5066af56"></a>ev_create_switch_xrefs&#160;</td><td class="fielddoc">
<p>Create xrefs for a custom jump table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jumpea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the jump insn </td></tr>
    <tr><td class="paramname">si</td><td>(const <a class="el" href="structswitch__info__t.html" title="Information about a switch statement. ">switch_info_t</a> *) switch information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>must return 1 Must be implemented if module uses custom jump tables, <a class="el" href="group___s_w_i__.html#ga9c8b1cc7dc7face3d01f48b8e2b78135">SWI_CUSTOM</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a4d200c0f82f9d32c4bda426aadc3e9dc"></a>ev_is_align_insn&#160;</td><td class="fielddoc">
<p>Is the instruction created only for alignment purposes?. </p>
<p>Do not directly call this function, use <a class="el" href="idp_8hpp.html#a0fd0a2914e9e1fe193175e78a5a6cdeb" title="If the instruction at &#39;ea&#39; looks like an alignment instruction, return its length in bytes...">is_align_insn()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(ea_t) - instruction address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">number</td><td>of bytes in the instruction </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ad25720c4c15166242743be03127e0a84"></a>ev_is_alloca_probe&#160;</td><td class="fielddoc">
<p>Does the function at 'ea' behave as __alloca_probe? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">0</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0af754550ff044ee8ba2bf4b90037eb4b1"></a>ev_delay_slot_insn&#160;</td><td class="fielddoc">
<p>Get delay slot instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) instruction address in question, if answer is positive then set 'ea' to the delay slot insn address </td></tr>
    <tr><td class="paramname">bexec</td><td>(bool *) execute slot if jumping, initially set to 'true' </td></tr>
    <tr><td class="paramname">fexec</td><td>(bool *) execute slot if not jumping, initally set to 'true' </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>positive answer </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>ordinary insn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Input 'ea' may point to the instruction with a delay slot or to the delay slot instruction itself. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aef2ae5d93a83201e69e626f1308ca21f"></a>ev_is_sp_based&#160;</td><td class="fielddoc">
<p>Check whether the operand is relative to stack pointer or frame pointer This event is used to determine how to output a stack variable If not implemented, then all operands are sp based by default. </p>
<p>Implement this event only if some stack references use frame pointer instead of stack pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>(int *) out, combination of <a class="el" href="group___o_p___f_p___s_p.html">SP/FP operand flags</a> </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) </td></tr>
    <tr><td class="paramname">op</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction. ">op_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 not implemented </dd>
<dd>
1 ok </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a9b1b28b1c71c8d77861f528c78eade90"></a>ev_can_have_type&#160;</td><td class="fielddoc">
<p>Can the operand have a type as offset, segment, decimal, etc? (for example, a register AX can't have a type, meaning that the user can't change its representation. </p>
<p>see <a class="el" href="bytes_8hpp.html" title="Contains functions that deal with individual byte characteristics. ">bytes.hpp</a> for information about types and flags) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction. ">op_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">1</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a2996b08408addef7f16b01180e2efdc3"></a>ev_cmp_operands&#160;</td><td class="fielddoc">
<p>Compare instruction operands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction. ">op_t</a>*) </td></tr>
    <tr><td class="paramname">op2</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction. ">op_t</a>*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>equal </td></tr>
    <tr><td class="paramname">-1</td><td>not equal </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0abf55189dd21fab945f35eab8fa9088cf"></a>ev_adjust_refinfo&#160;</td><td class="fielddoc">
<p>Called from apply_fixup before converting operand to reference. </p>
<p>Can be used for changing the reference info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ri</td><td>(<a class="el" href="structrefinfo__t.html" title="Information about a reference. ">refinfo_t</a> *) </td></tr>
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">n</td><td>(int) operand number </td></tr>
    <tr><td class="paramname">fd</td><td>(const <a class="el" href="structfixup__data__t.html">fixup_data_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - do not create an offset </dd>
<dd>
0 - not implemented or refinfo adjusted </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae7391e79329dedc4bd100a629e61f569"></a>ev_get_operand_string&#160;</td><td class="fielddoc">
<p>Request text string for operand (cli, java, ...). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>(qstring *) </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">opnum</td><td>(int) operand number, -1 means any string operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 no string (or empty string) &gt;0 original string length without terminating zero </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a8dcc2b7307fb19045e6acf6d6016d89d"></a>ev_get_reg_name&#160;</td><td class="fielddoc">
<p>Generate text representation of a register. </p>
<p>Most processor modules do not need to implement this callback. It is useful only if <a class="el" href="structprocessor__t.html#a0b75be7e30d134b1b288ab686c312307" title="array of register names ">processor_t::reg_names</a>[reg] does not provide the correct register name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>(qstring *) output buffer </td></tr>
    <tr><td class="paramname">reg</td><td>(int) internal register number as defined in the processor module </td></tr>
    <tr><td class="paramname">width</td><td>(size_t) register width in bytes </td></tr>
    <tr><td class="paramname">reghi</td><td>(int) if not -1 then this function will return the register pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if error, strlen(buf) otherwise </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aaddd272c33f61d746f850746a5451a9f"></a>ev_str2reg&#160;</td><td class="fielddoc">
<p>Convert a register name to a register number. </p>
<p>The register number is the register index in the <a class="el" href="structprocessor__t.html#a0b75be7e30d134b1b288ab686c312307" title="array of register names ">processor_t::reg_names</a> array Most processor modules do not need to implement this callback It is useful only if <a class="el" href="structprocessor__t.html#a0b75be7e30d134b1b288ab686c312307" title="array of register names ">processor_t::reg_names</a>[reg] does not provide the correct register names </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regname</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>register number + 1 </dd>
<dd>
0 not implemented or could not be decoded </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a0fa6560db645bbc4751b5cee7760cf30"></a>ev_get_autocmt&#160;</td><td class="fielddoc">
<p>Callback: get dynamic auto comment. </p>
<p>Will be called if the autocomments are enabled and the comment retrieved from ida.int starts with '$!'. 'insn' contains valid info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>(qstring *) output buffer </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>new comment has been generated </td></tr>
    <tr><td class="paramname">0</td><td>callback has not been handled. the buffer must not be changed in this case </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a0de30b0749ce3401ec930a1904bcb274"></a>ev_get_bg_color&#160;</td><td class="fielddoc">
<p>Get item background color. </p>
<p>Plugins can hook this callback to color disassembly lines dynamically </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>(<a class="el" href="pro_8h.html#a3df5040891132e50157aee66affdf1de" title="background color in RGB ">bgcolor_t</a> *), out </td></tr>
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>color set </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a1f6f7128d8213f4433c5c94e16635aa7"></a>ev_is_jump_func&#160;</td><td class="fielddoc">
<p>Is the function a trivial "jump" function?. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
    <tr><td class="paramname">jump_target</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
    <tr><td class="paramname">func_pointer</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">0</td><td>don't know </td></tr>
    <tr><td class="paramname">1</td><td>yes, see 'jump_target' and 'func_pointer' </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a54a6dfcb795c6d8167ebdb5116bcf579"></a>ev_func_bounds&#160;</td><td class="fielddoc">
<p><a class="el" href="funcs_8hpp.html#af27a7eb0cc4e210f6ffa21e6aa06e589" title="Determine the boundaries of a new function. ">find_func_bounds()</a> finished its work. </p>
<p>The module may fine tune the function bounds </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">possible_return_code</td><td>(int *), in/out </td></tr>
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
    <tr><td class="paramname">max_func_end_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) (from the kernel's point of view) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a726a4a238e3c41a53777e5e04b911029"></a>ev_verify_sp&#160;</td><td class="fielddoc">
<p>All function instructions have been analyzed. </p>
<p>Now the processor module can analyze the stack pointer for the whole function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;0</td><td>bad stack pointer </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae161c5b9fbb789a4ed5a9e88539802f7"></a>ev_verify_noreturn&#160;</td><td class="fielddoc">
<p>The kernel wants to set 'noreturn' flags for a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: ok. any other value: do not set 'noreturn' flag </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a4e97147365c7e9487f57ffc2bd82894a"></a>ev_create_func_frame&#160;</td><td class="fielddoc">
<p>Create a function frame for a newly created function Set up frame size, its attributes etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a73d90e8e78294379f7efdb58e0fa4ca9"></a>ev_get_frame_retsize&#160;</td><td class="fielddoc">
<p>Get size of function return address in bytes If this eveny is not implemented, the kernel will assume. </p>
<ul>
<li>8 bytes for 64-bit function</li>
<li>4 bytes for 32-bit function</li>
<li>2 bytes otherwise If this eveny is not implemented, the kernel will assume <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frsize</td><td>(int *) frame size (out) </td></tr>
    <tr><td class="paramname">pfn</td><td>(const <a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *), can't be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd></dl>
</li>
</ul>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae3c289592a68b9362e83fab157097cbf"></a>ev_get_stkvar_scale_factor&#160;</td><td class="fielddoc">
<p>Should stack variable references be multiplied by a coefficient before being used in the stack frame?. </p>
<p>Currently used by TMS320C55 because the references into the stack should be multiplied by 2 </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="group___p_r__.html#gaf96c8c11c1d33bf6b8b45cd0c596b9a9" title="use processor_t::get_stkvar_scale callback ">PR_SCALE_STKVARS</a> should be set to use this callback </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>scaling factor, 0-not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ad1283662b4901e2ea7d85af70bc7f817"></a>ev_demangle_name&#160;</td><td class="fielddoc">
<p>Demangle a C++ (or another language) name into a user-readable string. </p>
<p>This event is called by <a class="el" href="name_8hpp.html#aa9c7d3ed8cf3b79dca8ee2262c9f3b56" title="Demangle a name. ">demangle_name()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>(int32 *) value to return from <a class="el" href="name_8hpp.html#aa9c7d3ed8cf3b79dca8ee2262c9f3b56" title="Demangle a name. ">demangle_name()</a> </td></tr>
    <tr><td class="paramname">out</td><td>(<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce" title="regular string ">qstring</a> *) output buffer. may be NULL </td></tr>
    <tr><td class="paramname">name</td><td>(const char *) mangled name </td></tr>
    <tr><td class="paramname">disable_mask</td><td>(uint32) flags to inhibit parts of output or compiler info/other (see MNG_) </td></tr>
    <tr><td class="paramname">demreq</td><td>(demreq_type_t) operation to perform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: 1 if success, 0-not implemented </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if you call <a class="el" href="name_8hpp.html#aa9c7d3ed8cf3b79dca8ee2262c9f3b56" title="Demangle a name. ">demangle_name()</a> from the handler, protect against recursion! </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a6362bc58103da0a115d1c15c3ce41fe1"></a>ev_add_cref&#160;</td><td class="fielddoc">
<p>A code reference is being created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">type</td><td>(<a class="el" href="group__xref__type.html#ga44e2b79869a9595bbe6265ff2026aa98" title="CODE xref types. ">cref_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel cref creation </dd>
<dd>
0 - not implemented or continue </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a64a7c332726e8a44498b879162e4d24f"></a>ev_add_dref&#160;</td><td class="fielddoc">
<p>A data reference is being created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">type</td><td>(<a class="el" href="group__xref__type.html#ga78aab6d0d6bd9cb4904bbdbb5ac4fa71" title="DATA xref types. ">dref_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel dref creation </dd>
<dd>
0 - not implemented or continue </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a58ace401d909f95b24a1e8fcae9810d4"></a>ev_del_cref&#160;</td><td class="fielddoc">
<p>A code reference is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">expand</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel cref deletion </dd>
<dd>
0 - not implemented or continue </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0affd5e295fef35e6175c3db5150ca5396"></a>ev_del_dref&#160;</td><td class="fielddoc">
<p>A data reference is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel dref deletion </dd>
<dd>
0 - not implemented or continue </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a00c056a442c9524d2c7f7e90669c8275"></a>ev_coagulate_dref&#160;</td><td class="fielddoc">
<p>Data reference is being analyzed. </p>
<p>plugin may correct 'code_ea' (e.g. for thumb mode refs, we clear the last bit) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">may_define</td><td>(bool) </td></tr>
    <tr><td class="paramname">code_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel dref analysis </dd>
<dd>
0 - not implemented or continue </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a1edb3d05f21feee48cf7d271032dcbc2"></a>ev_may_show_sreg&#160;</td><td class="fielddoc">
<p>The kernel wants to display the segment registers in the messages window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if the kernel should not show the segment registers. (assuming that the module has done it) </dd>
<dd>
0 - not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a268f12ba7873a0778460826a59e268aa"></a>ev_loader_elf_machine&#160;</td><td class="fielddoc">
<p>ELF loader machine type checkpoint. </p>
<p>A plugin check of the 'machine_type'. If it is the desired one, the the plugin fills 'p_procname' with the processor name (one of the names present in <a class="el" href="structprocessor__t.html#a7f36c9be272d994bc341b3fcb78726f6" title="short processor names (NULL terminated). ">processor_t::psnames</a>). 'p_pd' is used to handle relocations, otherwise can be left untouched. This event occurs for each newly loaded ELF file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">li</td><td>(linput_t *) </td></tr>
    <tr><td class="paramname">machine_type</td><td>(int) </td></tr>
    <tr><td class="paramname">p_procname</td><td>(const char **) </td></tr>
    <tr><td class="paramname">p_pd</td><td>(proc_def_t **) (see ldr\elf.h) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>e_machine value (if it is different from the original e_machine value, procname and 'p_pd' will be ignored and the new value will be used) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a0ca73f0b4d8eb1c319f668cb8c520b86"></a>ev_auto_queue_empty&#160;</td><td class="fielddoc">
<p>One analysis queue is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>(<a class="el" href="auto_8hpp.html#ae3fe1a7af243ca1880188111193297cf" title="identifies an autoanalysis queue - see Autoanalysis queues ">atype_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void see also <a class="el" href="namespaceidb__event.html#a0feb6e648b4e6e3f0ed954abea672784a8d4508d4ede7ad33b0df402700a95740">idb_event::auto_empty_finally</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aac26bb0ae2ef530084cbeb8c3078bd43"></a>ev_validate_flirt_func&#160;</td><td class="fielddoc">
<p>Flirt has recognized a library function. </p>
<p>This callback can be used by a plugin or proc module to intercept it and validate such a function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">funcname</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>do not create a function, </td></tr>
    <tr><td class="paramname">0</td><td>function is validated </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a1cf0dcb7a9e11a5220863ddb8722bd09"></a>ev_adjust_libfunc_ea&#160;</td><td class="fielddoc">
<p>Called when a signature module has been matched against bytes in the database. </p>
<p>This is used to compute the offset at which a particular module's libfunc should be applied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>(const idasgn_t *) </td></tr>
    <tr><td class="paramname">libfun</td><td>(const libfunc_t *) </td></tr>
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>'ea' initially contains the ea_t of the start of the pattern match </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>the ea_t pointed to by the third argument was modified. </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>not modified. use default algorithm. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a5f2ba1e8f4586958cc9cef0f514667e2"></a>ev_assemble&#160;</td><td class="fielddoc">
<p>Assemble an instruction. </p>
<p>(display a warning if an error is found). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin</td><td>(<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc" title="unsigned 8 bit value ">uchar</a> *) pointer to output opcode buffer </td></tr>
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) linear address of instruction </td></tr>
    <tr><td class="paramname">cs</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) cs of instruction </td></tr>
    <tr><td class="paramname">ip</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) ip of instruction </td></tr>
    <tr><td class="paramname">use32</td><td>(bool) is 32bit segment? </td></tr>
    <tr><td class="paramname">line</td><td>(const char *) line to assemble </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the instruction in bytes </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0abe5d814d671bf8564be4212cefb61238"></a>ev_extract_address&#160;</td><td class="fielddoc">
<p>Extract address from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_ea</td><td>(ea_t *), out </td></tr>
    <tr><td class="paramname">screen_ea</td><td>(ea_t) </td></tr>
    <tr><td class="paramname">string</td><td>(const char *) </td></tr>
    <tr><td class="paramname">position</td><td>(size_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>kernel should use the standard algorithm </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a5cccab69e499642d3873649769de31cf"></a>ev_realcvt&#160;</td><td class="fielddoc">
<p>Floating point -&gt; IEEE conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(void *) pointer to data </td></tr>
    <tr><td class="paramname">e</td><td>(uint16 *) internal IEEE format data </td></tr>
    <tr><td class="paramname">swt</td><td>(uint16) operation (see <a class="el" href="ieee_8h.html#a236e96bab295bd7292d14604355699c6" title="Floating point conversion function: implemented by processor_t::realcvt. ">realcvt()</a> in <a class="el" href="ieee_8h.html" title="IEEE floating point functions. ">ieee.h</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 not implemented </dd>
<dd>
1 ok </dd>
<dd>
<a class="el" href="group___r_e_a_l___e_r_r_o_r__.html">Floating point/IEEE Conversion codes</a> on error </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a87a749b6180d2fc6c4b4436df4eddc2f"></a>ev_gen_asm_or_lst&#160;</td><td class="fielddoc">
<p>Callback: generating asm or lst file. </p>
<p>The kernel calls this callback twice, at the beginning and at the end of listing generation. The processor module can intercept this event and adjust its output </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting</td><td>(bool) beginning listing generation </td></tr>
    <tr><td class="paramname">fp</td><td>(FILE *) output file </td></tr>
    <tr><td class="paramname">is_asm</td><td>(bool) true:assembler, false:listing </td></tr>
    <tr><td class="paramname">flags</td><td>(int) flags passed to <a class="el" href="loader_8hpp.html#a777046093020c790ec43bd207166bf09" title="Generate an output file. ">gen_file()</a> </td></tr>
    <tr><td class="paramname">outline</td><td>(gen_outline_t **) ptr to ptr to outline callback. if this callback is defined for this code, it will be used by the kernel to output the generated lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ac4729fbc053f45a29a9370369eda3c21"></a>ev_gen_map_file&#160;</td><td class="fielddoc">
<p>Generate map file. </p>
<p>If not implemented the kernel itself will create the map file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlines</td><td>(int *) number of lines in map file (-1 means write error) </td></tr>
    <tr><td class="paramname">fp</td><td>(FILE *) output file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 not implemented </dd>
<dd>
1 ok </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>write error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a5fa3981e47a82bf57567c9e17fc69344"></a>ev_create_flat_group&#160;</td><td class="fielddoc">
<p>Create special segment representing the flat group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_base</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">bitness</td><td>(int) </td></tr>
    <tr><td class="paramname">dataseg_sel</td><td>(<a class="el" href="pro_8h.html#a633a07e2920351503da14c0adcd3edfd" title="segment selector ">sel_t</a>) return value is ignored </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a5b7199e3af11fa25303602ba6093f307"></a>ev_getreg&#160;</td><td class="fielddoc">
<p>IBM PC only internal request, should never be used for other purpose Get register value by internal index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regval</td><td>(uval_t *), out </td></tr>
    <tr><td class="paramname">regnum</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd>
<dd>
-1 failed (undefined value or bad regnum) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ada84ccdbecd828227cf5891289d4a442"></a>ev_analyze_prolog&#160;</td><td class="fielddoc">
<p>Analyzes function prolog, epilog, and updates purge, and function attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) start of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ad634ef51985fc184b924840188825199"></a>ev_calc_spdelta&#160;</td><td class="fielddoc">
<p>Calculate amount of change to sp for the given insn. </p>
<p>This event is required to decompile code snippets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spdelta</td><td>(<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1" title="signed value used by the processor. ">sval_t</a> *) </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a44113b21d13cb880233a52c38a84bea9"></a>ev_calcrel&#160;</td><td class="fielddoc">
<p>Reserved. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a05a8170fb8a243187c118dbcaa1fd954"></a>ev_find_reg_value&#160;</td><td class="fielddoc">
<p>Find register value via a register tracker. </p>
<p>The returned value in 'out' is valid before executing the instruction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(uval_t *) pointer to the found value </td></tr>
    <tr><td class="paramname">pinsn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction </td></tr>
    <tr><td class="paramname">reg</td><td>(int) register index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if implemented, and value was found </dd>
<dd>
0 not implemented, -1 decoding failed, or no value found </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ac0cdca25f97d06dfa6630abfd371cfea"></a>ev_find_op_value&#160;</td><td class="fielddoc">
<p>Find operand value via a register tracker. </p>
<p>The returned value in 'out' is valid before executing the instruction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(uval_t *) pointer to the found value </td></tr>
    <tr><td class="paramname">pinsn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction </td></tr>
    <tr><td class="paramname">opn</td><td>(int) operand index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if implemented, and value was found </dd>
<dd>
0 not implemented, -1 decoding failed, or no value found </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a5776ce7324886d47497e6b55fa985c2f"></a>ev_last_cb_before_debugger&#160;</td><td class="fielddoc">
<p>START OF DEBUGGER CALLBACKS. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a035854be86d6e113db368eba96ec6a44"></a>ev_next_exec_insn&#160;</td><td class="fielddoc">
<p>Get next address to be executed This function must return the next address to be executed. </p>
<p>If the instruction following the current one is executed, then it must return <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39; ">BADADDR</a> Usually the instructions to consider are: jumps, branches, calls, returns. This function is essential if the 'single step' is not supported in hardware. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *), out: pointer to the answer </td></tr>
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">tid</td><td>(int) current therad id </td></tr>
    <tr><td class="paramname">getreg</td><td>(::processor_t::regval_getter_t *) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
    <tr><td class="paramname">1</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aa552c713d33cbf8b7088aa1279316279"></a>ev_calc_step_over&#160;</td><td class="fielddoc">
<p>Calculate the address of the instruction which will be executed after "step over". </p>
<p>The kernel will put a breakpoint there. If the step over is equal to step into or we can not calculate the address, return <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39; ">BADADDR</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) pointer to the answer </td></tr>
    <tr><td class="paramname">ip</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
    <tr><td class="paramname">1</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a15f393eb309882f724a87ba8680ed8b2"></a>ev_calc_next_eas&#160;</td><td class="fielddoc">
<p>Calculate list of addresses the instruction in 'insn' may pass control to. </p>
<p>This callback is required for source level debugging. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>(<a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4" title="vector of addresses ">eavec_t</a> *), out: array for the results. </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">over</td><td>(bool) calculate for step over (ignore call targets) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>incalculable (indirect jumps, for example) </td></tr>
    <tr><td class="paramname">&gt;=0</td><td>number of addresses of called functions in the array. They must be put at the beginning of the array (0 if over=true) </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a2f4da6daaf29d96db466f024a41b6cd6"></a>ev_get_macro_insn_head&#160;</td><td class="fielddoc">
<p>Calculate the start of a macro instruction. </p>
<p>This notification is called if IP points to the middle of an instruction </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *), out: answer, <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39; ">BADADDR</a> means normal instruction </td></tr>
    <tr><td class="paramname">ip</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
    <tr><td class="paramname">1</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae19b6e2ec1f0f8dff6822e23d26ecf6f"></a>ev_get_dbr_opnum&#160;</td><td class="fielddoc">
<p>Get the number of the operand to be displayed in the debugger reference view (text mode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opnum</td><td>(int *) operand number (out, -1 means no such operand) </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
    <tr><td class="paramname">1</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a744ce375c380a22ef248cb5c8b2fe91e"></a>ev_insn_reads_tbit&#160;</td><td class="fielddoc">
<p>Check if insn will read the TF bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">getreg</td><td>(::processor_t::regval_getter_t *) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>yes, will generate 'step' exception </td></tr>
    <tr><td class="paramname">1</td><td>yes, will store the TF bit in memory </td></tr>
    <tr><td class="paramname">0</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a731a21b42e23b3a93212acc929590a44"></a>ev_clean_tbit&#160;</td><td class="fielddoc">
<p>Clear the TF bit after an insn like pushf stored it in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">getreg</td><td>(::processor_t::regval_getter_t *) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a4c99f3d0cae242c834db12429824c412"></a>ev_get_idd_opinfo&#160;</td><td class="fielddoc">
<p>Get operand information. </p>
<p>This callback is used to calculate the operand value for double clicking on it, hints, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opinf</td><td>(<a class="el" href="structidd__opinfo__t.html" title="Instruction operand information. ">idd_opinfo_t</a> *) the output buffer </td></tr>
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">n</td><td>(int) operand number </td></tr>
    <tr><td class="paramname">thread_id</td><td>(int) current thread id </td></tr>
    <tr><td class="paramname">getreg</td><td>(::processor_t::regval_getter_t *) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1-ok, 0-failed </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ac3cc0f61a972f10943ffcb9b512bbfcd"></a>ev_get_reg_info&#160;</td><td class="fielddoc">
<p>Get register information by its name. </p>
<p>example: "ah" returns:</p><ul>
<li>main_regname="eax"</li>
<li><a class="el" href="classbitrange__t.html" title="This class manages the offset and size of a value that occupies a number of contiguous bits within so...">bitrange_t</a> = { offset==8, nbits==8 }</li>
</ul>
<p>This callback may be unimplemented if the register names are all present in <a class="el" href="structprocessor__t.html#a0b75be7e30d134b1b288ab686c312307" title="array of register names ">processor_t::reg_names</a> and they all have the same size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main_regname</td><td>(const char **), out </td></tr>
    <tr><td class="paramname">bitrange</td><td>(<a class="el" href="classbitrange__t.html" title="This class manages the offset and size of a value that occupies a number of contiguous bits within so...">bitrange_t</a> *), out: position and size of the value within 'main_regname' (empty bitrange == whole register) </td></tr>
    <tr><td class="paramname">regname</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>failed (not found) </td></tr>
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ab943223f3ca8d738c6a33aa2d1d5d5b2"></a>ev_setup_til&#160;</td><td class="fielddoc">
<p>Setup default type libraries. </p>
<p>(called after loading a new file into the database). The processor module may load tils, setup memory model and perform other actions required to set up the type system. This is an optional callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aa97519e3d4a7c838b5bea894471d1605"></a>ev_get_abi_info&#160;</td><td class="fielddoc">
<p>Get all possible ABI names and optional extensions for given compiler abiname/option is a string entirely consisting of letters, digits and underscore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abi_names</td><td>(qstrvec_t *) - all possible ABis each in form abiname-opt1-opt2-... </td></tr>
    <tr><td class="paramname">abi_opts</td><td>(qstrvec_t *) - array of all possible options in form "opt:description" or opt:hint-line#description </td></tr>
    <tr><td class="paramname">comp</td><td>(comp_t) - compiler ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aa72e8b0fefe1ccb4f97c3ab7d963403e"></a>ev_max_ptr_size&#160;</td><td class="fielddoc">
<p>Get maximal size of a pointer in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max possible size of a pointer </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a445f041d8992406148c70d2265aeeaeb"></a>ev_get_default_enum_size&#160;</td><td class="fielddoc">
<p>Get default enum size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cm</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model ">cm_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sizeof(enum) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a4d4579748c4e9235161552951f41243e"></a>ev_get_cc_regs&#160;</td><td class="fielddoc">
<p>Get register allocation convention for given calling convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regs</td><td>(<a class="el" href="classcallregs__t.html" title="Register allocation calling convention. ">callregs_t</a> *), out </td></tr>
    <tr><td class="paramname">cc</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model ">cm_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 </dd>
<dd>
0 - not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a47951bf3b092b3fbc1750c48988a00a0"></a>ev_get_stkarg_offset&#160;</td><td class="fielddoc">
<p>Get offset from SP to the first stack argument. </p>
<p>For example: pc: 0, hppa: -0x34, ppc: 0x38 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the offset (usually 0) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a81a915a392ccbe061321cf7fd8bb3091"></a>ev_shadow_args_size&#160;</td><td class="fielddoc">
<p>Get size of shadow args in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">shadow_args_size</td><td>(int *) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) (may be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if filled *shadow_args_size </dd>
<dd>
0 - not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0afa23f72943023fbb22dbc682beca757c"></a>ev_get_simd_types&#160;</td><td class="fielddoc">
<p>Get SIMD-related types according to given attributes ant/or argument location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(::simd_info_vec_t *) </td></tr>
    <tr><td class="paramname">simd_attrs</td><td>(const <a class="el" href="structsimd__info__t.html" title="SIMD type info. ">simd_info_t</a> *), may be NULL </td></tr>
    <tr><td class="paramname">argloc</td><td>(const <a class="el" href="classargloc__t.html" title="Describes an argument location. ">argloc_t</a> *), may be NULL </td></tr>
    <tr><td class="paramname">create_tifs</td><td>(bool) return valid <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> objects, create if neccessary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of found types, -1-error If name==NULL, initialize all SIMD types </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae4a7bab1ce8d51fef3323630c8ab5986"></a>ev_calc_cdecl_purged_bytes&#160;</td><td class="fielddoc">
<p>Calculate number of purged bytes after call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the call instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of purged bytes (usually add sp, N) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a04dc0f7ffee5e8ce6d9bd2659f5fb48d"></a>ev_calc_purged_bytes&#160;</td><td class="fielddoc">
<p>Calculate number of purged bytes by the given function type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_purged_bytes</td><td>(int *) ptr to output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fti</td><td>(const <a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details()) ">func_type_data_t</a> *) func type details </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 </dd>
<dd>
0 - not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a0d69f230a16256b7c97ec87e16a6f814"></a>ev_calc_retloc&#160;</td><td class="fielddoc">
<p>Calculate return value location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">retloc</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location. ">argloc_t</a> *) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rettype</td><td>(const <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> *) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cc</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model ">cm_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 not implemented </dd>
<dd>
1 ok, </dd>
<dd>
-1 error </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a8db94c9ea9bd7e6039821e897b952f82"></a>ev_calc_arglocs&#160;</td><td class="fielddoc">
<p>Calculate function argument locations. </p>
<p>This callback should fill retloc, all arglocs, and stkargs. This callback is never called for <a class="el" href="group___c_m___c_c__.html#ga377054c414ac35be6e5e9bf6c550b390" title="locations of all arguments and the return value are present in the function declaration. ">CM_CC_SPECIAL</a> functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fti</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details()) ">func_type_data_t</a> *) points to the func type info </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a4537faf41cc6bd81946ec4cfd4b2db5a"></a>ev_calc_varglocs&#160;</td><td class="fielddoc">
<p>Calculate locations of the arguments that correspond to '...'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ftd</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details()) ">func_type_data_t</a> *), inout: info about all arguments (including varargs) </td></tr>
    <tr><td class="paramname">regs</td><td>(<a class="el" href="structregobjs__t.html" title="Collection of register objects. ">regobjs_t</a> *) buffer for register values </td></tr>
    <tr><td class="paramname">stkargs</td><td>(<a class="el" href="structrelobj__t.html" title="Relocatable object. ">relobj_t</a> *) stack arguments </td></tr>
    <tr><td class="paramname">nfixed</td><td>(int) number of fixed arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0ae6d879a79e41acf6c15241f8a8616413"></a>ev_adjust_argloc&#160;</td><td class="fielddoc">
<p>Adjust argloc according to its type/size and platform endianess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argloc</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location. ">argloc_t</a> *), inout </td></tr>
    <tr><td class="paramname">type</td><td>(const <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> *), may be NULL NULL means primitive type of given size </td></tr>
    <tr><td class="paramname">size</td><td>(int) 'size' makes no sense if type != NULL (type-&gt;get_size() should be used instead) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0af54f85e43c332ae869c5e9015e1f3203"></a>ev_lower_func_type&#160;</td><td class="fielddoc">
<p>Get function arguments which should be converted to pointers when lowering function prototype. </p>
<p>The processor module can also modify 'fti' in order to make non-standard conversion of some arguments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argnums</td><td>(intvec_t *), out - numbers of arguments to be converted to pointers in acsending order </td></tr>
    <tr><td class="paramname">fti</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details()) ">func_type_data_t</a> *), inout func type details (special values -1/-2 for return value - position of hidden 'retstr' argument: -1 - at the beginning, -2 - at the end) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>argnums was filled </td></tr>
    <tr><td class="paramname">2</td><td>argnums was filled and made substantial changes to fti </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0aacf3158cd80a47e0f87786c60f6f1b6a"></a>ev_equal_reglocs&#160;</td><td class="fielddoc">
<p>Are 2 register arglocs the same?. </p>
<p>We need this callback for the pc module. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location. ">argloc_t</a> *) </td></tr>
    <tr><td class="paramname">a2</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location. ">argloc_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">-1</td><td>no </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a5551d04ee2e1a9f77a06ea2da02e5ffc"></a>ev_use_stkarg_type&#160;</td><td class="fielddoc">
<p>Use information about a stack argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the push instruction which pushes the function argument into the stack </td></tr>
    <tr><td class="paramname">arg</td><td>(const <a class="el" href="structfuncarg__t.html" title="Information about a single function argument. ">funcarg_t</a> *) argument info </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>failed, the kernel will create a comment with the argument name or type for the instruction </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a239afca977e96df72bf4680c8843662a"></a>ev_use_regarg_type&#160;</td><td class="fielddoc">
<p>Use information about register argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">idx</td><td>(int *) pointer to the returned value, may contain:<ul>
<li>idx of the used argument, if the argument is defined in the current instruction, a comment will be applied by the kernel</li>
<li>idx | <a class="el" href="idp_8hpp.html#a062e4611e8876c7b1608cbecab0d94ed" title="processor_t::use_regarg_type uses this bit in the return value to indicate that the register value ha...">REG_SPOIL</a> - argument is spoiled by the instruction</li>
<li>-1 if the instruction doesn't change any registers</li>
<li>-2 if the instruction spoils all registers </li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the instruction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rargs</td><td>(const <a class="el" href="typeinf_8hpp.html#a6b5faeba43c9a59ec3aae166657ff78a" title="vector of function argument objects ">funcargvec_t</a> *) vector of register arguments (including regs extracted from scattered arguments) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a97d8ef8f70c0d9e0e53726ab6cea7671"></a>ev_use_arg_types&#160;</td><td class="fielddoc">
<p>Use information about callee arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the call instruction </td></tr>
    <tr><td class="paramname">fti</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details()) ">func_type_data_t</a> *) info about function type </td></tr>
    <tr><td class="paramname">rargs</td><td>(<a class="el" href="typeinf_8hpp.html#a6b5faeba43c9a59ec3aae166657ff78a" title="vector of function argument objects ">funcargvec_t</a> *) array of register arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 (and removes handled arguments from fti and rargs) </dd>
<dd>
0 not implemented </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a63c06a7cbeccfbc66ba9981ccde80e77"></a>ev_arg_addrs_ready&#160;</td><td class="fielddoc">
<p>Argument address info is ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">n</td><td>(int) number of formal arguments </td></tr>
    <tr><td class="paramname">tif</td><td>(<a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> *) call prototype </td></tr>
    <tr><td class="paramname">addrs</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) argument intilization addresses </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0: do not save into idb; other values mean "ok to save" </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a8341bbf9f53b19f61d4d7adcdc51783b"></a>ev_decorate_name&#160;</td><td class="fielddoc">
<p>Decorate/undecorate a C symbol name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outbuf</td><td>(<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce" title="regular string ">qstring</a> *) output buffer </td></tr>
    <tr><td class="paramname">name</td><td>(const char *) name of symbol </td></tr>
    <tr><td class="paramname">mangle</td><td>(bool) true-mangle, false-unmangle </td></tr>
    <tr><td class="paramname">cc</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model ">cm_t</a>) calling convention </td></tr>
    <tr><td class="paramname">type</td><td>(const <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> *) name type (NULL-unknown) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success </dd>
<dd>
0 not implemented or failed </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2d184a313fab28b517e82c1717d562a0a562fb16cff7e5e0c0f5750788c24d99c"></a>ev_loader&#160;</td><td class="fielddoc">
<p>This code and higher ones are reserved for the loaders. </p>
<p>The arguments and the return values are defined by the loaders </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac1e0b7613ad405cf7b165b59c9ba02c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int processor_t::get_segm_bitness </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get segment bitness. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td><a class="el" href="group___p_r__.html#ga51211ffe0d08c32dece2d318a462e139" title="segments are 64-bit by default ">PR_DEFSEG64</a> </td></tr>
    <tr><td class="paramname">1</td><td><a class="el" href="group___p_r__.html#ga91a0359d79ef2256ffb0b29ae7e481cb" title="segments are 32-bit by default ">PR_DEFSEG32</a> </td></tr>
    <tr><td class="paramname">0</td><td>none specified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe691f9f3c80817bd9d1e19e8ee5f926"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int processor_t::get_stkvar_scale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stack variable scaling factor. </p>
<p>Useful for processors who refer to the stack with implicit scaling factor. TMS320C55 for example: SP(#1) really refers to (SP+2) </p>

</div>
</div>
<a class="anchor" id="ad58c2a400e68a56e9299338aab2b2029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool processor_t::is_canon_insn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>itype</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the given value specify a valid instruction for this instruction set?. </p>
<p>See <a class="el" href="structprocessor__t.html#a35f080945b61116baab1bfc67f195f62" title="icode of the first instruction ">instruc_start</a> and <a class="el" href="structprocessor__t.html#a5bc594ff4b32014972b205b5c9b07deb" title="icode of the last instruction + 1 ">instruc_end</a> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae86f81b3e716d4bf17f424688cf5aeab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> processor_t::cnbits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits in a byte for code segments (usually 8). </p>
<p>IDA supports values up to supported address bits size </p>

</div>
</div>
<a class="anchor" id="a94c90b8e3ee733f9f843fc6297bd1977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> processor_t::dnbits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits in a byte for non-code segments (usually 8). </p>
<p>IDA supports values up to supported address bit size </p>

</div>
</div>
<a class="anchor" id="a7f36c9be272d994bc341b3fcb78726f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const* processor_t::psnames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>short processor names (NULL terminated). </p>
<p>Each name should be shorter than 9 characters </p>

</div>
</div>
<a class="anchor" id="adb54cc1d2faab6891ad190e2e5b7bf08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const* processor_t::plnames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>long processor names (NULL terminated). </p>
<p>No restriction on name lengths. </p>

</div>
</div>
<a class="anchor" id="a13faa23b7174cbdbae5da42c71602d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structasm__t.html">asm_t</a>* const* processor_t::assemblers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to array of target assembler definitions. </p>
<p>You may change this array when current processor is changed. (NULL terminated) </p>

</div>
</div>
<a class="anchor" id="a9414a4e585ab47514144871a585cc120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbytes__t.html">bytes_t</a>* processor_t::codestart</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of typical code start sequences. </p>
<p>This array is used when a new file is loaded to find the beginnings of code sequences. This array is terminated with a zero length item. </p>

</div>
</div>
<a class="anchor" id="ab3849caf742c36dc743f0aa88267221a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbytes__t.html">bytes_t</a>* processor_t::retcodes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of 'return' instruction opcodes. </p>
<p>This array is used to determine form of autogenerated locret_... labels. The last item of it should be { 0, NULL } This array may be NULL Better way of handling return instructions is to define the <a class="el" href="">is_ret_insn</a> callback in the notify() function </p>

</div>
</div>
<a class="anchor" id="ab1ed6541f40864dcf175219db42afa90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char processor_t::real_width[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of digits in floating numbers after the decimal point. </p>
<p>If an element of this array equals 0, then the corresponding floating point data is not used for the processor. This array is used to align numbers in the output.</p><ul>
<li>real_width[0] - number of digits for short floats (only PDP-11 has them)</li>
<li>real_width[1] - number of digits for "float"</li>
<li>real_width[2] - number of digits for "double"</li>
<li>real_width[3] - number of digits for "long double"</li>
</ul>
<p>Example: IBM PC module has { 0,7,15,19 } </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="idp_8hpp.html">idp.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
